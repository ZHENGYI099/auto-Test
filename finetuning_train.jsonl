{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case1_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Helper: Get MSI property (per spec)\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Constants\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFileName = \"CMDExtension.log\"\n$scheduledTaskPath = \"\\Microsoft\\CMD\\Cloud Managed Desktop Extension Health Evaluation\"\n$wmiNamespace = \"root\\cmd\\clientagent\"\n\n# Check admin\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    exit 1\n}\n\n# Check if MSI exists\nif (-not (Test-Path $msiPath)) {\n    Write-Result -Msg \"MSI file not found at $msiPath\" -Success $false\n    Stop-Transcript\n    exit 2\n} else {\n    Write-Result -Msg \"MSI file found at $msiPath\" -Success $true\n}\n\n# Check if product already installed\nfunction Is-ProductInstalled {\n    param([string]$displayName)\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n    )\n    foreach ($regPath in $regPaths) {\n        $keys = Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue\n        foreach ($key in $keys) {\n            try {\n                $name = (Get-ItemProperty -Path $key.PSPath -Name \"DisplayName\" -ErrorAction SilentlyContinue).DisplayName\n                if ($name -and ($name.Trim() -eq $displayName.Trim())) {\n                    return $true\n                }\n            } catch {}\n        }\n    }\n    return $false\n}\n\nif (Is-ProductInstalled -displayName $productName) {\n    Write-Result -Msg \"$productName is already installed\" -Success $false\n    Write-Host \"Please uninstall before running this test.\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 3\n} else {\n    Write-Result -Msg \"$productName is not installed (ready for test)\" -Success $true\n}\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n$msiLogPath = Join-Path $logDir \"cmdextension_install_$timestamp.log\"\n$installCmd = \"msiexec.exe /i `\"$msiPath`\" /qn /l*v `\"$msiLogPath`\"\"\nWrite-Host \"Installing MSI: $installCmd\" -ForegroundColor Gray\n\n$exitCode = $null\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i\", \"`\"$msiPath`\"\", \"/qn\", \"/l*v\", \"`\"$msiLogPath`\"\" -Wait -PassThru -WindowStyle Hidden\n    $exitCode = $process.ExitCode\n} catch {\n    Write-Result -Msg \"Exception during MSI install - $($_.Exception.Message)\" -Success $false\n    $exitCode = $null\n}\n\nif ($exitCode -eq 0 -or $exitCode -eq 3010) {\n    Write-Result -Msg \"MSI installation succeeded (exit code $exitCode)\" -Success $true\n} elseif ($exitCode -eq 1603) {\n    Write-Result -Msg \"MSI installation failed - Fatal error (exit code 1603)\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 1603\n} elseif ($exitCode -eq 1618) {\n    Write-Result -Msg \"MSI installation failed - Another installation in progress (exit code 1618)\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 1618\n} elseif ($exitCode -eq 1925) {\n    Write-Result -Msg \"MSI installation failed - Insufficient privileges (exit code 1925)\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 1925\n} else {\n    Write-Result -Msg \"MSI installation failed - Unknown exit code $exitCode\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit $exitCode\n}\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: VERIFICATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 5: Verify product in installed programs\nWrite-Host \"Verifying installed programs...\" -ForegroundColor Gray\nif (Is-ProductInstalled -displayName $productName) {\n    Write-Result -Msg \"$productName is present in installed programs\" -Success $true\n} else {\n    Write-Result -Msg \"$productName is NOT present in installed programs\" -Success $false\n}\n\n# Step 6: Verify service running\nWrite-Host \"Checking service '$serviceName' status...\" -ForegroundColor Gray\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    $isRunning = ($svc.Status -eq \"Running\")\n    Write-Result -Msg \"Service '$serviceName' is running\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Service '$serviceName' not found\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 7: Verify service properties (Status, StartupType, LogOnAs)\nWrite-Host \"Checking service properties...\" -ForegroundColor Gray\ntry {\n    $svcWMI = Get-WmiObject -Class Win32_Service -Filter \"Name='$serviceName'\" -ErrorAction Stop\n    $statusMatch = ($svcWMI.State -ne $null -and $svcWMI.State.Trim() -eq \"Running\")\n    $startupMatch = ($svcWMI.StartMode -ne $null -and $svcWMI.StartMode.Trim() -eq \"Auto\")\n    $delayedMatch = ($svcWMI.DelayedAutoStart -eq $true)\n    $logonMatch = ($svcWMI.StartName -ne $null -and $svcWMI.StartName.Trim() -eq \"LocalSystem\")\n    Write-Result -Msg \"Service '$serviceName' - Status is Running\" -Success $statusMatch\n    if (-not $statusMatch) {\n        Write-Host \"[DEBUG] Actual State - $($svcWMI.State)\" -ForegroundColor Yellow\n    }\n    Write-Result -Msg \"Service '$serviceName' - Startup Type is Automatic (Delayed Start)\" -Success ($startupMatch -and $delayedMatch)\n    if (-not ($startupMatch -and $delayedMatch)) {\n        Write-Host \"[DEBUG] Actual StartMode - $($svcWMI.StartMode), DelayedAutoStart - $($svcWMI.DelayedAutoStart)\" -ForegroundColor Yellow\n    }\n    Write-Result -Msg \"Service '$serviceName' - Log On As is Local System\" -Success $logonMatch\n    if (-not $logonMatch) {\n        Write-Host \"[DEBUG] Actual StartName - $($svcWMI.StartName)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"WMI query for service '$serviceName' failed\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 8: Verify log file exists\nWrite-Host \"Checking log file presence...\" -ForegroundColor Gray\n$logFilePath = Join-Path $logFolder $logFileName\nif (Test-Path $logFilePath) {\n    Write-Result -Msg \"$logFileName is present in $logFolder\" -Success $true\n} else {\n    Write-Result -Msg \"$logFileName is NOT present in $logFolder\" -Success $false\n    Write-Host \"[DEBUG] Checked path - $logFilePath\" -ForegroundColor Yellow\n}\n\n# Step 9: Verify scheduled task exists\nWrite-Host \"Checking scheduled task...\" -ForegroundColor Gray\ntry {\n    $task = Get-ScheduledTask -TaskPath \"\\Microsoft\\CMD\\\" -TaskName \"Cloud Managed Desktop Extension Health Evaluation\" -ErrorAction Stop\n    Write-Result -Msg \"Scheduled task 'Cloud Managed Desktop Extension Health Evaluation' is present\" -Success $true\n} catch {\n    Write-Result -Msg \"Scheduled task 'Cloud Managed Desktop Extension Health Evaluation' is NOT present\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 10: Verify WMI namespace exists (no \"Invalid namespace\" error)\nWrite-Host \"Checking WMI namespace '$wmiNamespace'...\" -ForegroundColor Gray\ntry {\n    $null = Get-WmiObject -Namespace $wmiNamespace -List -ErrorAction Stop\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' is valid (no error)\" -Success $true\n} catch {\n    $errMsg = $_.Exception.Message\n    $isInvalid = $errMsg -match \"Invalid namespace\"\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' is invalid\" -Success (-not $isInvalid)\n    if ($isInvalid) {\n        Write-Host \"[DEBUG] WMI error - $errMsg\" -ForegroundColor Yellow\n    }\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n$uninstallCmd = \"msiexec.exe /x `\"$msiPath`\" /qn /l*v `\"$msiLogPath`\"\"\nWrite-Host \"Uninstalling MSI: $uninstallCmd\" -ForegroundColor Gray\n\n$uninstallExitCode = $null\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x\", \"`\"$msiPath`\"\", \"/qn\", \"/l*v\", \"`\"$msiLogPath`\"\" -Wait -PassThru -WindowStyle Hidden\n    $uninstallExitCode = $process.ExitCode\n} catch {\n    Write-Result -Msg \"Exception during MSI uninstall - $($_.Exception.Message)\" -Success $false\n    $uninstallExitCode = $null\n}\n\nif ($uninstallExitCode -eq 0 -or $uninstallExitCode -eq 3010) {\n    Write-Result -Msg \"MSI uninstall succeeded (exit code $uninstallExitCode)\" -Success $true\n} elseif ($uninstallExitCode -eq 1605) {\n    Write-Result -Msg \"MSI uninstall failed - Product not installed (exit code 1605)\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n} else {\n    Write-Result -Msg \"MSI uninstall failed - Exit code $uninstallExitCode\" -Success $false\n    Write-Host \"See log: $msiLogPath\" -ForegroundColor Yellow\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case2_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    exit 1\n}\n\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$programFiles64 = \"C:\\Program Files\"\n$programFiles32 = \"C:\\Program Files (x86)\"\n$extensionFolderName = \"Microsoft Cloud Managed Desktop Extension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$infraLogPath = \"$logFolder\\InfraLogs\\AgentMainService.log\"\n$scheduledTaskName = \"Cloud Managed Desktop Extension Health Evaluation\"\n$scheduledTaskPath = \"\\Microsoft\\CMD\\$scheduledTaskName\"\n$wmiNamespace = \"root\\cmd\\clientagent\"\n$regPath64 = \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\"\n$regPath32 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\"\n\n# Check if product already installed (by registry or product code)\nfunction Get-InstalledProductCode {\n    param([string]$msiPath)\n    $productCode = Get-MSIProperty -msiPath $msiPath -property \"ProductCode\"\n    if ($null -eq $productCode) { return $null }\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productCode\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productCode\"\n    )\n    foreach ($reg in $regPaths) {\n        if (Test-Path $reg) { return $productCode }\n    }\n    return $null\n}\n\n$installedProductCode = Get-InstalledProductCode -msiPath $msiPath\nif ($installedProductCode) {\n    Write-Host \"Product already installed - uninstalling before test...\" -ForegroundColor Yellow\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    Write-Host \"Uninstall exit code: $exitCode\" -ForegroundColor Gray\n    Start-Sleep -Seconds 10\n}\n\nWrite-Host \"Pre-check complete.\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing MSI...\" -ForegroundColor Cyan\n\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiPath`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    Write-Host \"Install exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"MSI installed successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI installation failed (exit code $exitCode)\" -Success $false\n        Write-Host \"[DEBUG] Install command: msiexec.exe /i `\"$msiPath`\" /qn\" -ForegroundColor Yellow\n        exit 2\n    }\n} catch {\n    Write-Result -Msg \"MSI installation threw exception\" -Success $false\n    Write-Host \"[DEBUG] Exception during install - $($_.Exception.Message)\" -ForegroundColor Yellow\n    exit 2\n}\n\nWrite-Host \"Waiting 1 minute after install...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 60\n\n# ============================================================\n# PHASE 3: UNINSTALLATION\n# ============================================================\nWrite-Host \"Uninstalling MSI...\" -ForegroundColor Cyan\n\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    Write-Host \"Uninstall exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"MSI uninstalled successfully (exit code $exitCode)\" -Success $true\n    } elseif ($exitCode -eq 1605) {\n        Write-Result -Msg \"MSI uninstall - product not installed (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI uninstall failed (exit code $exitCode)\" -Success $false\n        Write-Host \"[DEBUG] Uninstall command: msiexec.exe /x `\"$msiPath`\" /qn\" -ForegroundColor Yellow\n        exit 3\n    }\n} catch {\n    Write-Result -Msg \"MSI uninstall threw exception\" -Success $false\n    Write-Host \"[DEBUG] Exception during uninstall - $($_.Exception.Message)\" -ForegroundColor Yellow\n    exit 3\n}\n\nWrite-Host \"Waiting 10 seconds after uninstall...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 10\n\n# ============================================================\n# PHASE 4: VERIFICATION\n# ============================================================\nWrite-Host \"Starting post-uninstall verification...\" -ForegroundColor Cyan\n\n# Step 6: Verify there is NO “Microsoft Cloud Managed Desktop Extension” in installed programs\nfunction IsProductInUninstallList {\n    param([string]$productName)\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n    )\n    foreach ($regPath in $regPaths) {\n        $items = Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue\n        foreach ($item in $items) {\n            try {\n                $displayName = (Get-ItemProperty -Path $item.PSPath -Name \"DisplayName\" -ErrorAction SilentlyContinue).DisplayName\n                if ($displayName -and ($displayName.Trim() -eq $productName.Trim())) {\n                    return $true\n                }\n            } catch {}\n        }\n    }\n    return $false\n}\n$isInUninstall = IsProductInUninstallList -productName $productName\nWrite-Result -Msg \"Product not present in installed programs\" -Success (-not $isInUninstall)\nif ($isInUninstall) {\n    Write-Host \"[DEBUG] Product '$productName' still present in uninstall list.\" -ForegroundColor Yellow\n}\n\n# Step 7: Verify there is NO “CloudManagedDesktopExtension” service\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($null -eq $svc) {\n        Write-Result -Msg \"Service '$serviceName' not present\" -Success $true\n    } else {\n        Write-Result -Msg \"Service '$serviceName' should not exist\" -Success $false\n        Write-Host \"[DEBUG] Service found - Status: $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Service '$serviceName' not present (exception)\" -Success $true\n}\n\n# Step 8: Verify there is NO “Microsoft Cloud Managed Desktop Extension” service (redundant, same as above)\n# Already checked above.\n\n# Step 9: Verify there is NO “Microsoft Cloud Managed Desktop Extension” folder in Program Files/Program Files (x86)\n$foldersToCheck = @(\n    (Join-Path $programFiles64 $extensionFolderName),\n    (Join-Path $programFiles32 $extensionFolderName)\n)\nforeach ($folder in $foldersToCheck) {\n    $exists = Test-Path $folder\n    Write-Result -Msg \"Folder '$folder' not present\" -Success (-not $exists)\n    if ($exists) {\n        Write-Host \"[DEBUG] Folder still exists: $folder\" -ForegroundColor Yellow\n    }\n}\n\n# Step 10: Verify “CMDExtension.log” is still present\n$cmdExtensionLog = Join-Path $logFolder \"CMDExtension.log\"\n$exists = Test-Path $cmdExtensionLog\nWrite-Result -Msg \"CMDExtension.log is present\" -Success $exists\nif (-not $exists) {\n    Write-Host \"[DEBUG] Log file missing: $cmdExtensionLog\" -ForegroundColor Yellow\n}\n\n# Step 11: Verify “Service is on OnStop” is printed in AgentMainService.log\nif (Test-Path $infraLogPath) {\n    try {\n        $content = Get-Content -Path $infraLogPath -ErrorAction Stop\n        $found = $false\n        foreach ($line in $content) {\n            if ($line -match \"Service is on OnStop\") {\n                $found = $true\n                break\n            }\n        }\n        Write-Result -Msg \"'Service is on OnStop' found in AgentMainService.log\" -Success $found\n        if (-not $found) {\n            Write-Host \"[DEBUG] 'Service is on OnStop' not found in $infraLogPath\" -ForegroundColor Yellow\n        }\n    } catch {\n        Write-Result -Msg \"Error reading AgentMainService.log\" -Success $false\n        Write-Host \"[DEBUG] Exception reading $infraLogPath - $($_.Exception.Message)\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"AgentMainService.log not present\" -Success $false\n    Write-Host \"[DEBUG] Log file missing: $infraLogPath\" -ForegroundColor Yellow\n}\n\n# Step 12: Verify there is NOT “Cloud Managed Desktop Extension Health Evaluation” scheduled task\ntry {\n    $task = Get-ScheduledTask -TaskPath \"\\Microsoft\\CMD\\\" -TaskName $scheduledTaskName -ErrorAction SilentlyContinue\n    $notPresent = ($null -eq $task)\n    Write-Result -Msg \"Scheduled task '$scheduledTaskName' not present\" -Success $notPresent\n    if (-not $notPresent) {\n        Write-Host \"[DEBUG] Scheduled task still present: $scheduledTaskName\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Scheduled task '$scheduledTaskName' not present (exception)\" -Success $true\n}\n\n# Step 13: Verify WMI namespace \"root\\cmd\\clientagent\" returns \"Invalid namespace\"\ntry {\n    $wmiObj = Get-WmiObject -Namespace $wmiNamespace -Class \"__Namespace\" -ErrorAction Stop\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' should be invalid\" -Success $false\n    Write-Host \"[DEBUG] WMI namespace '$wmiNamespace' exists unexpectedly.\" -ForegroundColor Yellow\n} catch {\n    $msg = $_.Exception.Message\n    $isInvalidNamespace = $msg -match \"Invalid namespace\"\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' is invalid\" -Success $isInvalidNamespace\n    if (-not $isInvalidNamespace) {\n        Write-Host \"[DEBUG] WMI error message - $msg\" -ForegroundColor Yellow\n    }\n}\n\n# Step 14: Verify there is no \"CloudManagementDesktop\" registry key under HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft (x86) and HKLM:\\SOFTWARE\\Microsoft (x64)\n$regKeysToCheck = @(\n    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\",\n    \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\"\n)\nforeach ($regKey in $regKeysToCheck) {\n    $exists = Test-Path $regKey\n    Write-Result -Msg \"Registry key '$regKey' not present\" -Success (-not $exists)\n    if ($exists) {\n        Write-Host \"[DEBUG] Registry key still exists: $regKey\" -ForegroundColor Yellow\n    }\n}\n\n# ============================================================\n# PHASE 5: SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case10_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Helper: Get MSI property (version, etc.)\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI paths and product names\n$msiFolder = \"C:\\VMShare\"\n$msiV1 = Join-Path $msiFolder \"cmdextension.v1.msi\"\n$msiV2 = Join-Path $msiFolder \"cmdextension.v2.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n\n# Get versions from MSI files\n$v1Version = Get-MSIProperty -msiPath $msiV1 -property \"ProductVersion\"\n$v2Version = Get-MSIProperty -msiPath $msiV2 -property \"ProductVersion\"\n\nif ([string]::IsNullOrWhiteSpace($v1Version) -or [string]::IsNullOrWhiteSpace($v2Version)) {\n    Write-Result -Msg \"Failed to read MSI versions\" -Success $false\n    Write-Host \"[DEBUG] v1Version: '$v1Version', v2Version: '$v2Version'\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 2\n}\n\nWrite-Host \"Detected MSI versions - v1: $v1Version, v2: $v2Version\" -ForegroundColor Gray\n\n# Pre-check: Is product already installed?\nfunction Get-InstalledProductVersion {\n    param([string]$displayName)\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n    )\n    foreach ($regPath in $regPaths) {\n        $keys = Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue\n        foreach ($key in $keys) {\n            $props = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue\n            if ($props.DisplayName -and $props.DisplayName.Trim() -eq $displayName) {\n                return $props.DisplayVersion.Trim()\n            }\n        }\n    }\n    return $null\n}\n\n$installedVersion = Get-InstalledProductVersion -displayName $productName\nif ($installedVersion) {\n    Write-Host \"Product '$productName' is already installed (version: $installedVersion)\" -ForegroundColor Yellow\n    Write-Host \"Uninstalling existing product before test...\" -ForegroundColor Yellow\n    # Try to uninstall existing version\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiV2`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    if (($exitCode -eq 0) -or ($exitCode -eq 1605)) {\n        Write-Result -Msg \"Pre-cleanup uninstall succeeded (exit code: $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"Pre-cleanup uninstall failed (exit code: $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 3\n    }\n    Start-Sleep -Seconds 5\n}\n\nWrite-Host \"Pre-check complete.\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"PHASE 2: Installing v2 (latest)...\" -ForegroundColor Cyan\n\n# Step 4: Run command: msiexec /i cmdextension.v2.msi /qn\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiV2`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"Installed v2 ($v2Version) successfully (exit code: $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"Failed to install v2 ($v2Version) (exit code: $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 4\n    }\n} catch {\n    Write-Result -Msg \"Exception during v2 install - $($_.Exception.Message)\" -Success $false\n    Stop-Transcript\n    exit 5\n}\n\nWrite-Host \"Waiting 1 minute before downgrade attempt...\" -ForegroundColor Gray\nStart-Sleep -Seconds 60\n\n# ============================================================\n# PHASE 3: DOWNGRADE ATTEMPT\n# ============================================================\nWrite-Host \"PHASE 3: Attempting downgrade to v1...\" -ForegroundColor Cyan\n\n# Step 5: Run command msiexec /i cmdextension.v1.msi /qn\n# Expected: Setup should fail (exit code 1603)\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiV1`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    # According to MSI error codes, 1603 = install failure\n    if ($exitCode -eq 1603) {\n        Write-Result -Msg \"Downgrade to v1 ($v1Version) failed as expected (exit code: $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"Downgrade to v1 ($v1Version) did NOT fail as expected (exit code: $exitCode)\" -Success $false\n        Write-Host \"[DEBUG] Expected exit code: 1603, Actual: $exitCode\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Exception during v1 downgrade install - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# PHASE 4: VERIFICATION\n# ============================================================\nWrite-Host \"PHASE 4: Verifying installed product and version...\" -ForegroundColor Cyan\n\n# Step 6: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs, and its Version is [v2-version-number].\n$actualVersion = Get-InstalledProductVersion -displayName $productName\nif ($actualVersion) {\n    $actualVersionTrimmed = $actualVersion.Trim()\n    $expectedVersionTrimmed = $v2Version.Trim()\n    $isMatch = ($actualVersionTrimmed -eq $expectedVersionTrimmed)\n    Write-Result -Msg \"Product '$productName' is installed\" -Success $true\n    Write-Result -Msg \"Product version is $expectedVersionTrimmed\" -Success $isMatch\n    if (-not $isMatch) {\n        Write-Host \"[DEBUG] Expected: '$expectedVersionTrimmed', Actual: '$actualVersionTrimmed'\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"Product '$productName' is NOT installed\" -Success $false\n    Write-Host \"[DEBUG] Expected: '$productName', Actual: Not found\" -ForegroundColor Yellow\n}\n\n# ============================================================\n# PHASE 4b: SERVICE STATUS VERIFICATION\n# ============================================================\nWrite-Host \"PHASE 4b: Verifying service status...\" -ForegroundColor Cyan\n\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($svc -eq $null) {\n        Write-Result -Msg \"Service '$serviceName' not found\" -Success $false\n    } else {\n        if ($svc.Status -eq 'Running') {\n            Write-Result -Msg \"Service '$serviceName' is running\" -Success $true\n        } else {\n            Write-Result -Msg \"Service '$serviceName' is not running (Status: $($svc.Status))\" -Success $false\n        }\n    }\n} catch {\n    Write-Result -Msg \"Exception during service status check - $($_.Exception.Message)\" -Success $false\n}\n\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 5: CLEANUP\n# ============================================================\nWrite-Host \"PHASE 5: Test cleanup - uninstall v2...\" -ForegroundColor Cyan\n\n# Step 7: Run command: msiexec /x cmdextension.v2.msi /qn\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiV2`\" /qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    if (($exitCode -eq 0) -or ($exitCode -eq 1605)) {\n        Write-Result -Msg \"Uninstalled v2 ($v2Version) successfully (exit code: $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"Failed to uninstall v2 ($v2Version) (exit code: $exitCode)\" -Success $false\n        Write-Host \"[DEBUG] Uninstall exit code: $exitCode\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Exception during v2 uninstall - $($_.Exception.Message)\" -Success $false\n}\n\nWrite-Host \"\"\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case11_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR: Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI paths and product name\n$msiDir = \"C:\\VMShare\"\n$msiV1 = Join-Path $msiDir \"cmdextension.v1.msi\"\n$msiV2 = Join-Path $msiDir \"cmdextension.v2.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFolder = \"C:\\ProgramData\\CloudManagedDesktopExtension\\Logs\"\n$logFileName = \"CMDExtension.log\"\n$logPath = Join-Path $logFolder $logFileName\n\n# Check MSI files exist\nforeach ($msi in @($msiV1, $msiV2)) {\n    if (-not (Test-Path $msi)) {\n        Write-Result -Msg \"MSI file $msi not found\" -Success $false\n        Stop-Transcript\n        exit 2\n    }\n}\n\n# Get versions from MSI files\n$v1Version = Get-MSIProperty -msiPath $msiV1 -property \"ProductVersion\"\n$v2Version = Get-MSIProperty -msiPath $msiV2 -property \"ProductVersion\"\nif ([string]::IsNullOrWhiteSpace($v1Version) -or [string]::IsNullOrWhiteSpace($v2Version)) {\n    Write-Result -Msg \"Failed to read MSI ProductVersion\" -Success $false\n    Stop-Transcript\n    exit 3\n}\nWrite-Host \"Detected cmdextension.v1.msi version: $v1Version\" -ForegroundColor Gray\nWrite-Host \"Detected cmdextension.v2.msi version: $v2Version\" -ForegroundColor Gray\n\n# Check if v2 > v1\nif ([version]$v2Version -le [version]$v1Version) {\n    Write-Result -Msg \"v2 version ($v2Version) is not greater than v1 ($v1Version)\" -Success $false\n    Stop-Transcript\n    exit 4\n}\n\n# Check if product already installed\n$installed = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -eq $productName }\nif ($installed) {\n    Write-Host \"Product '$productName' already installed. Attempting uninstall for clean state...\" -ForegroundColor Yellow\n    try {\n        $uninstallCmd = \"msiexec.exe /x `\"$($installed.IdentifyingNumber)`\" /qn\"\n        Write-Host \"Running: $uninstallCmd\" -ForegroundColor Gray\n        $proc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x\", \"`\"$($installed.IdentifyingNumber)`\"\", \"/qn\" -Wait -PassThru\n        $exitCode = $proc.ExitCode\n        Write-Host \"Uninstall exit code: $exitCode\" -ForegroundColor Gray\n        Start-Sleep -Seconds 10\n    } catch {\n        Write-Result -Msg \"Failed to uninstall existing product - $($_.Exception.Message)\" -Success $false\n        Stop-Transcript\n        exit 5\n    }\n}\n\n# ============================================================\n# PHASE 2: INSTALLATION (v1)\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION - v1\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 4: Install v1 MSI (use /qn for silent automation)\nWrite-Host \"Installing $msiV1 with SVCENV=Test...\" -ForegroundColor Gray\ntry {\n    $proc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i\", \"`\"$msiV1`\"\", \"/qn\", \"SVCENV=Test\" -Wait -PassThru\n    $exitCode = $proc.ExitCode\n    Write-Host \"Install exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"cmdextension.v1.msi installed successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"cmdextension.v1.msi install failed (exit code $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 6\n    }\n} catch {\n    Write-Result -Msg \"Exception during v1 install - $($_.Exception.Message)\" -Success $false\n    Stop-Transcript\n    exit 7\n}\n\n# Service status check after v1 install\nWrite-Host \"Checking service '$serviceName' status after v1 install...\" -ForegroundColor Gray\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    $isRunning = ($svc.Status -eq 'Running')\n    Write-Result -Msg \"Service '$serviceName' is running after v1 install\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Service status: $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Service '$serviceName' not found after v1 install - $($_.Exception.Message)\" -Success $false\n}\n\n# Step 5: Wait 1 minute\nWrite-Host \"Waiting 1 minute for service and agent startup...\" -ForegroundColor Gray\nStart-Sleep -Seconds 60\n\n# Step 5.1: Check CMDExtension.log for \"DeviceClient created and opened successfully\"\nWrite-Host \"Checking CMDExtension.log for agent startup message...\" -ForegroundColor Gray\nif (Test-Path $logPath) {\n    try {\n        $logContent = Get-Content $logPath -Raw\n        $expectedLogMsg = \"DeviceClient created and opened successfully\"\n        $found = $logContent -like \"*$expectedLogMsg*\"\n        Write-Result -Msg \"CMDExtension.log contains '$expectedLogMsg'\" -Success $found\n        if (-not $found) {\n            Write-Host \"[DEBUG] Log does not contain expected message. Actual content:\" -ForegroundColor Yellow\n            Write-Host $logContent.Substring([Math]::Max(0, $logContent.Length - 1000)) -ForegroundColor Yellow\n        }\n    } catch {\n        Write-Result -Msg \"Failed to read CMDExtension.log - $($_.Exception.Message)\" -Success $false\n    }\n} else {\n    Write-Result -Msg \"CMDExtension.log not found at $logPath\" -Success $false\n}\n\n# Step 5.2: WMI Table Check\nWrite-Host \"Checking SchedulerEntity WMI table for unique PolicyId...\" -ForegroundColor Gray\ntry {\n    $sc = Get-WmiObject -Namespace \"root/cmd/clientagent\" -Class \"SchedulerEntity\"\n    if ($sc) {\n        $test1 = $sc | ForEach-Object { $_.PolicyId }\n        $test2 = $test1 | Select-Object -Unique\n        $isUnique = ($test1.Count -eq $test2.Count)\n        Write-Result -Msg \"SchedulerEntity PolicyId uniqueness check (v1)\" -Success $isUnique\n        if (-not $isUnique) {\n            Write-Host \"[DEBUG] PolicyId values: $($test1 -join ', ')\" -ForegroundColor Yellow\n        }\n    } else {\n        Write-Result -Msg \"No SchedulerEntity instances found (v1)\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during WMI PolicyId check (v1) - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# PHASE 3: UPGRADE TO v2\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: UPGRADE TO v2\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 6: Install v2 MSI (/qn for silent automation)\nWrite-Host \"Upgrading to $msiV2 with SVCENV=Test...\" -ForegroundColor Gray\ntry {\n    $proc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i\", \"`\"$msiV2`\"\", \"/qn\", \"SVCENV=Test\" -Wait -PassThru\n    $exitCode = $proc.ExitCode\n    Write-Host \"Upgrade exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"cmdextension.v2.msi upgraded successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"cmdextension.v2.msi upgrade failed (exit code $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 8\n    }\n} catch {\n    Write-Result -Msg \"Exception during v2 upgrade - $($_.Exception.Message)\" -Success $false\n    Stop-Transcript\n    exit 9\n}\n\n# Service status check after v2 upgrade\nWrite-Host \"Checking service '$serviceName' status after v2 upgrade...\" -ForegroundColor Gray\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    $isRunning = ($svc.Status -eq 'Running')\n    Write-Result -Msg \"Service '$serviceName' is running after v2 upgrade\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Service status: $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Service '$serviceName' not found after v2 upgrade - $($_.Exception.Message)\" -Success $false\n}\n\n# Step 7: Wait 1 minute\nWrite-Host \"Waiting 1 minute for agent upgrade and service restart...\" -ForegroundColor Gray\nStart-Sleep -Seconds 60\n\n# Step 7.1: Check CMDExtension.log for \"DeviceClient created and opened successfully\"\nWrite-Host \"Checking CMDExtension.log for agent startup message after upgrade...\" -ForegroundColor Gray\nif (Test-Path $logPath) {\n    try {\n        $logContent = Get-Content $logPath -Raw\n        $expectedLogMsg = \"DeviceClient created and opened successfully\"\n        $found = $logContent -like \"*$expectedLogMsg*\"\n        Write-Result -Msg \"CMDExtension.log contains '$expectedLogMsg' after upgrade\" -Success $found\n        if (-not $found) {\n            Write-Host \"[DEBUG] Log does not contain expected message after upgrade. Actual content:\" -ForegroundColor Yellow\n            Write-Host $logContent.Substring([Math]::Max(0, $logContent.Length - 1000)) -ForegroundColor Yellow\n        }\n    } catch {\n        Write-Result -Msg \"Failed to read CMDExtension.log after upgrade - $($_.Exception.Message)\" -Success $false\n    }\n} else {\n    Write-Result -Msg \"CMDExtension.log not found at $logPath after upgrade\" -Success $false\n}\n\n# Step 7.2: WMI Table Check after upgrade\nWrite-Host \"Checking SchedulerEntity WMI table for unique PolicyId after upgrade...\" -ForegroundColor Gray\ntry {\n    $sc = Get-WmiObject -Namespace \"root/cmd/clientagent\" -Class \"SchedulerEntity\"\n    if ($sc) {\n        $test1 = $sc | ForEach-Object { $_.PolicyId }\n        $test2 = $test1 | Select-Object -Unique\n        $isUnique = ($test1.Count -eq $test2.Count)\n        Write-Result -Msg \"SchedulerEntity PolicyId uniqueness check (v2)\" -Success $isUnique\n        if (-not $isUnique) {\n            Write-Host \"[DEBUG] PolicyId values after upgrade: $($test1 -join ', ')\" -ForegroundColor Yellow\n        }\n    } else {\n        Write-Result -Msg \"No SchedulerEntity instances found (v2)\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during WMI PolicyId check (v2) - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# PHASE 4: VERIFY INSTALLED PROGRAM VERSION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: VERIFY INSTALLED PROGRAM VERSION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 8: Verify installed program and version\nWrite-Host \"Checking installed programs for '$productName' and version $v2Version...\" -ForegroundColor Gray\ntry {\n    $installed = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -eq $productName }\n    if ($installed) {\n        $actualVersion = $installed.Version\n        if ([string]::IsNullOrWhiteSpace($actualVersion)) {\n            Write-Result -Msg \"'$productName' installed but version is missing\" -Success $false\n        } else {\n            $isMatch = ($actualVersion.Trim() -eq $v2Version.Trim())\n            Write-Result -Msg \"'$productName' is installed with version $v2Version\" -Success $isMatch\n            if (-not $isMatch) {\n                Write-Host \"[DEBUG] Expected version: '$v2Version', Actual: '$actualVersion'\" -ForegroundColor Yellow\n            }\n        }\n    } else {\n        Write-Result -Msg \"'$productName' not found in installed programs\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception checking installed program version - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# PHASE 5: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 5: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 9: Uninstall v2 MSI\nWrite-Host \"Uninstalling $msiV2...\" -ForegroundColor Gray\ntry {\n    $proc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x\", \"`\"$msiV2`\"\", \"/qn\" -Wait -PassThru\n    $exitCode = $proc.ExitCode\n    Write-Host \"Uninstall exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010) -or ($exitCode -eq 1605)) {\n        Write-Result -Msg \"cmdextension.v2.msi uninstalled successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"cmdextension.v2.msi uninstall failed (exit code $exitCode)\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during v2 uninstall - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case13_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$svcDisplayName = \"Microsoft Cloud Managed Desktop Extension\"\n$svcRegistryPath_x64 = \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n$svcRegistryPath_x86 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFilePath = Join-Path $logFolder \"CMDExtension.log\"\n\n# Check if product is already installed\nfunction Get-InstalledProductCode {\n    param([string]$msiPath)\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = 'ProductCode'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-InstalledProductCode failed - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n$productCode = Get-InstalledProductCode -msiPath $msiPath\n$alreadyInstalled = $false\nif ($productCode) {\n    $regPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productCode\"\n    if (Test-Path $regPath) {\n        $alreadyInstalled = $true\n    }\n}\n\nif ($alreadyInstalled) {\n    Write-Host \"ERROR - Product already installed. Uninstall before running this test.\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\nWrite-Host \"Pre-checks passed.\" -ForegroundColor Green\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing client agent...\" -ForegroundColor Cyan\n\n$installArgs = \"/i `\"$msiPath`\" SVCENV=`\"Test`\" /qn\"\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $installArgs -Wait -PassThru\n$exitCode = $process.ExitCode\n\nif (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n    Write-Result -Msg \"MSI installed successfully (exit code $exitCode)\" -Success $true\n} else {\n    Write-Result -Msg \"MSI installation failed (exit code $exitCode)\" -Success $false\n    Write-Host \"Aborting test due to installation failure.\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for service to start (give 10 seconds for service startup)\nStart-Sleep -Seconds 10\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\n\n# Step 4: Restart service\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    Restart-Service -Name $serviceName -Force\n    Start-Sleep -Seconds 5\n    $svc = Get-Service -Name $serviceName\n    if ($svc.Status -eq \"Running\") {\n        Write-Result -Msg \"$svcDisplayName service restarted and running\" -Success $true\n    } else {\n        Write-Result -Msg \"$svcDisplayName service not running after restart\" -Success $false\n        Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Failed to restart $svcDisplayName service\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 5: Check log for \"Hit iot connection info cache\" and \"DeviceClient created and opened successfully\"\n$foundCacheHit = $false\n$foundDeviceClient = $false\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath -Raw\n    if ($logContent -match \"Hit iot connection info cache\") {\n        $foundCacheHit = $true\n    }\n    if ($logContent -match \"DeviceClient created and opened successfully\") {\n        $foundDeviceClient = $true\n    }\n    Write-Result -Msg \"Log contains 'Hit iot connection info cache'\" -Success $foundCacheHit\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully'\" -Success $foundDeviceClient\n    if (-not $foundCacheHit) {\n        Write-Host \"[DEBUG] Log missing 'Hit iot connection info cache'\" -ForegroundColor Yellow\n    }\n    if (-not $foundDeviceClient) {\n        Write-Host \"[DEBUG] Log missing 'DeviceClient created and opened successfully'\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"CMDExtension.log file not found\" -Success $false\n}\n\n# Step 6: Stop service\ntry {\n    Stop-Service -Name $serviceName -Force\n    Start-Sleep -Seconds 5\n    $svc = Get-Service -Name $serviceName\n    if ($svc.Status -eq \"Stopped\") {\n        Write-Result -Msg \"$svcDisplayName service stopped\" -Success $true\n    } else {\n        Write-Result -Msg \"$svcDisplayName service not stopped\" -Success $false\n        Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Failed to stop $svcDisplayName service\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 7: Registry path selection\nif (Test-Path $svcRegistryPath_x64) {\n    $regPath = $svcRegistryPath_x64\n} elseif (Test-Path $svcRegistryPath_x86) {\n    $regPath = $svcRegistryPath_x86\n} else {\n    Write-Result -Msg \"Registry path for extension settings not found\" -Success $false\n    $regPath = $null\n}\n\n# Step 8: Update \"IoTHostName\" to \"foo-device.net\"\nif ($null -eq $regPath) {\n    Write-Host \"Skipping registry update steps due to missing registry path.\" -ForegroundColor Yellow\n} else {\n    try {\n        Set-ItemProperty -Path $regPath -Name \"IoTHostName\" -Value \"foo-device.net\"\n        $actualIoTHostName = (Get-ItemProperty -Path $regPath -Name \"IoTHostName\").IoTHostName\n        if ([string]::IsNullOrWhiteSpace($actualIoTHostName)) {\n            Write-Result -Msg \"IoTHostName registry value is missing\" -Success $false\n        } else {\n            $isMatch = ($actualIoTHostName.Trim() -eq \"foo-device.net\")\n            Write-Result -Msg \"IoTHostName updated to foo-device.net\" -Success $isMatch\n            if (-not $isMatch) {\n                Write-Host \"[DEBUG] IoTHostName registry value - $actualIoTHostName\" -ForegroundColor Yellow\n            }\n        }\n    } catch {\n        Write-Result -Msg \"Failed to update IoTHostName registry value\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    }\n}\n\n# Step 9: Start service and wait 25 minutes\nif ($null -eq $regPath) {\n    Write-Host \"Skipping service start due to missing registry path.\" -ForegroundColor Yellow\n} else {\n    try {\n        Start-Service -Name $serviceName\n        Start-Sleep -Seconds 1500  # 25 minutes\n        $svc = Get-Service -Name $serviceName\n        if ($svc.Status -eq \"Running\") {\n            Write-Result -Msg \"$svcDisplayName service started (after IoTHostName update)\" -Success $true\n        } else {\n            Write-Result -Msg \"$svcDisplayName service not running after start\" -Success $false\n            Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n        }\n    } catch {\n        Write-Result -Msg \"Failed to start $svcDisplayName service\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    }\n}\n\n# Step 10: Check log for >1 \"IoTHostName: foo-device.net\" and \"DeviceClient created and opened successfully\"\n$foundIoTHostNameCount = 0\n$foundDeviceClientCount = 0\nif (Test-Path $logFilePath) {\n    $logLines = Get-Content $logFilePath\n    foreach ($line in $logLines) {\n        if ($line -match \"IoTHostName: foo-device.net\") {\n            $foundIoTHostNameCount++\n        }\n        if ($line -match \"DeviceClient created and opened successfully\") {\n            $foundDeviceClientCount++\n        }\n    }\n    Write-Result -Msg \"Log contains more than 1 'IoTHostName: foo-device.net'\" -Success ($foundIoTHostNameCount -gt 1)\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully' after IoTHostName update\" -Success ($foundDeviceClientCount -gt 0)\n    if ($foundIoTHostNameCount -le 1) {\n        Write-Host \"[DEBUG] IoTHostName: foo-device.net count - $foundIoTHostNameCount\" -ForegroundColor Yellow\n    }\n    if ($foundDeviceClientCount -eq 0) {\n        Write-Host \"[DEBUG] DeviceClient created and opened successfully count - $foundDeviceClientCount\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"CMDExtension.log file not found for IoTHostName check\" -Success $false\n}\n\n# Step 11: Update \"IoTDeviceId\" to \"fooDeviceId\", restart service, wait 10 minutes\nif ($null -eq $regPath) {\n    Write-Host \"Skipping IoTDeviceId registry update due to missing registry path.\" -ForegroundColor Yellow\n} else {\n    try {\n        Set-ItemProperty -Path $regPath -Name \"IoTDeviceId\" -Value \"fooDeviceId\"\n        $actualIoTDeviceId = (Get-ItemProperty -Path $regPath -Name \"IoTDeviceId\").IoTDeviceId\n        if ([string]::IsNullOrWhiteSpace($actualIoTDeviceId)) {\n            Write-Result -Msg \"IoTDeviceId registry value is missing\" -Success $false\n        } else {\n            $isMatch = ($actualIoTDeviceId.Trim() -eq \"fooDeviceId\")\n            Write-Result -Msg \"IoTDeviceId updated to fooDeviceId\" -Success $isMatch\n            if (-not $isMatch) {\n                Write-Host \"[DEBUG] IoTDeviceId registry value - $actualIoTDeviceId\" -ForegroundColor Yellow\n            }\n        }\n        Restart-Service -Name $serviceName -Force\n        Start-Sleep -Seconds 600  # 10 minutes\n        $svc = Get-Service -Name $serviceName\n        if ($svc.Status -eq \"Running\") {\n            Write-Result -Msg \"$svcDisplayName service restarted and running (after IoTDeviceId update)\" -Success $true\n        } else {\n            Write-Result -Msg \"$svcDisplayName service not running after restart\" -Success $false\n            Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n        }\n    } catch {\n        Write-Result -Msg \"Failed to update IoTDeviceId or restart service\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    }\n}\n\n# Step 12: Check log for error codes and successful registration after exceptions\n$foundError401002 = $false\n$foundDeviceNotFound = $false\n$foundStatus404 = $false\n$foundRegisterAsyncException = $false\n$foundUpdateIoTDeviceId = $false\n$foundDeviceClientAfterException = $false\n\nif (Test-Path $logFilePath) {\n    $logLines = Get-Content $logFilePath\n    $exceptionFound = $false\n    $deviceClientAfterException = $false\n    for ($i = 0; $i -lt $logLines.Count; $i++) {\n        $line = $logLines[$i]\n        if ($line -match '\"errorCode\":401002') { $foundError401002 = $true; $exceptionFound = $true }\n        if ($line -match \"DeviceNotFoundException\") { $foundDeviceNotFound = $true; $exceptionFound = $true }\n        if ($line -match \"status-code: 404\") { $foundStatus404 = $true; $exceptionFound = $true }\n        if ($line -match \"Exception on RegisterAsync\") { $foundRegisterAsyncException = $true; $exceptionFound = $true }\n        if ($line -match \"Update IoTDeviceId to\") { $foundUpdateIoTDeviceId = $true }\n        if ($exceptionFound -and $line -match \"DeviceClient created and opened successfully\") {\n            $foundDeviceClientAfterException = $true\n        }\n    }\n    $errorFound = $foundError401002 -or $foundDeviceNotFound -or $foundStatus404 -or $foundRegisterAsyncException\n    Write-Result -Msg \"Log contains error 401002 or DeviceNotFoundException or status-code: 404 or RegisterAsync exception\" -Success $errorFound\n    Write-Result -Msg \"Log contains 'Update IoTDeviceId to'\" -Success $foundUpdateIoTDeviceId\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully' after exceptions\" -Success $foundDeviceClientAfterException\n    if (-not $errorFound) {\n        Write-Host \"[DEBUG] No error logs found (401002/DeviceNotFoundException/status-code:404/RegisterAsync)\" -ForegroundColor Yellow\n    }\n    if (-not $foundUpdateIoTDeviceId) {\n        Write-Host \"[DEBUG] No 'Update IoTDeviceId to' log found\" -ForegroundColor Yellow\n    }\n    if (-not $foundDeviceClientAfterException) {\n        Write-Host \"[DEBUG] No 'DeviceClient created and opened successfully' after exceptions\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"CMDExtension.log file not found for error/registration check\" -Success $false\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"Starting cleanup phase...\" -ForegroundColor Cyan\n\n$uninstallArgs = \"/x `\"$msiPath`\" /qn\"\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $uninstallArgs -Wait -PassThru\n$exitCode = $process.ExitCode\n\nif (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n    Write-Result -Msg \"MSI uninstalled successfully (exit code $exitCode)\" -Success $true\n} else {\n    Write-Result -Msg \"MSI uninstall failed (exit code $exitCode)\" -Success $false\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case16_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI path and service name\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n\n# Helper function to get installed product code for MSI\nfunction Get-InstalledProductCode {\n    param([string]$msiName)\n    $products = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -eq $productName }\n    if ($products) {\n        return $products[0].IdentifyingNumber\n    }\n    return $null\n}\n\n# Check if product is already installed\n$alreadyInstalled = $false\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($svc) {\n        $alreadyInstalled = $true\n        Write-Host \"Product '$productName' is already installed.\" -ForegroundColor Yellow\n        Write-Host \"Attempting to uninstall before test...\" -ForegroundColor Yellow\n        $productCode = Get-InstalledProductCode -msiName $productName\n        if ($productCode) {\n            $uninstallCmd = \"msiexec.exe /x $productCode /qn\"\n            Write-Host \"Uninstalling with command: $uninstallCmd\" -ForegroundColor Gray\n            $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x $productCode /qn\" -Wait -PassThru\n            $exitCode = $process.ExitCode\n            if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n                Write-Result -Msg \"Pre-cleanup uninstall succeeded\" -Success $true\n            } else {\n                Write-Result -Msg \"Pre-cleanup uninstall failed - exit code $exitCode\" -Success $false\n            }\n        } else {\n            Write-Host \"Product code not found for uninstall.\" -ForegroundColor Yellow\n        }\n        # Wait for service to be removed\n        Start-Sleep -Seconds 10\n    }\n} catch {\n    Write-Host \"Exception during pre-check uninstall - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing client agent...\" -ForegroundColor Cyan\n\n$installArgs = \"/i `\"$msiPath`\" SVCENV=`\"Test`\" /qn\"\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $installArgs -Wait -PassThru\n    $exitCode = $process.ExitCode\n    Write-Host \"msiexec exit code: $exitCode\" -ForegroundColor Gray\n    if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n        Write-Result -Msg \"MSI install succeeded (exit code $exitCode)\" -Success $true\n    } elseif ($exitCode -eq 1603) {\n        Write-Result -Msg \"MSI install failed - Fatal error (exit code 1603)\" -Success $false\n        Write-Host \"Aborting test due to install failure.\" -ForegroundColor Red\n        Stop-Transcript\n        exit 1\n    } elseif ($exitCode -eq 1618) {\n        Write-Result -Msg \"MSI install failed - Another installation in progress (exit code 1618)\" -Success $false\n        Write-Host \"Aborting test due to install failure.\" -ForegroundColor Red\n        Stop-Transcript\n        exit 1\n    } elseif ($exitCode -eq 1925) {\n        Write-Result -Msg \"MSI install failed - Insufficient privileges (exit code 1925)\" -Success $false\n        Write-Host \"Aborting test due to install failure.\" -ForegroundColor Red\n        Stop-Transcript\n        exit 1\n    } else {\n        Write-Result -Msg \"MSI install failed - Unknown error (exit code $exitCode)\" -Success $false\n        Write-Host \"Aborting test due to install failure.\" -ForegroundColor Red\n        Stop-Transcript\n        exit 1\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI install - $($_.Exception.Message)\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for service to start (give it time after install)\nStart-Sleep -Seconds 10\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: VERIFICATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 2: Stop the service\nWrite-Host \"Stopping service '$productName'...\" -ForegroundColor Cyan\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    if ($svc.Status -eq \"Running\") {\n        Stop-Service -Name $serviceName -Force -ErrorAction Stop\n        Start-Sleep -Seconds 5\n        $svc = Get-Service -Name $serviceName -ErrorAction Stop\n        if ($svc.Status -eq \"Stopped\") {\n            Write-Result -Msg \"Service stopped successfully\" -Success $true\n        } else {\n            Write-Result -Msg \"Service stop failed - Status is $($svc.Status)\" -Success $false\n            Write-Host \"[DEBUG] Expected: 'Stopped', Actual: '$($svc.Status)'\" -ForegroundColor Yellow\n        }\n    } else {\n        Write-Result -Msg \"Service was not running before stop - Status is $($svc.Status)\" -Success $false\n        Write-Host \"[DEBUG] Expected: 'Running', Actual: '$($svc.Status)'\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Exception stopping service - $($_.Exception.Message)\" -Success $false\n}\n\n# Step 3: Wait for more than 24 hours (simulate guardian task restart)\n# For test automation, we speed up by waiting 2 minutes (as per discussion)\n$waitMinutes = 2\nWrite-Host \"Waiting $waitMinutes minutes to simulate guardian restart...\" -ForegroundColor Cyan\nStart-Sleep -Seconds ($waitMinutes * 60)\n\n# Step 4: Verify service status should be \"Running\"\nWrite-Host \"Verifying service '$productName' is running after guardian restart...\" -ForegroundColor Cyan\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    $isRunning = ($svc.Status -eq \"Running\")\n    Write-Result -Msg \"Service is running after guardian restart\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Expected: 'Running', Actual: '$($svc.Status)'\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Exception checking service status after guardian restart - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Uninstall MSI silently\nWrite-Host \"Uninstalling client agent...\" -ForegroundColor Cyan\ntry {\n    # Get product code for uninstall\n    $productCode = Get-InstalledProductCode -msiName $productName\n    if ($productCode) {\n        $uninstallArgs = \"/x $productCode /qn\"\n        $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $uninstallArgs -Wait -PassThru\n        $exitCode = $process.ExitCode\n        if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n            Write-Result -Msg \"MSI uninstall succeeded (exit code $exitCode)\" -Success $true\n        } elseif ($exitCode -eq 1605) {\n            Write-Result -Msg \"MSI uninstall failed - Product not installed (exit code 1605)\" -Success $false\n        } else {\n            Write-Result -Msg \"MSI uninstall failed - exit code $exitCode\" -Success $false\n        }\n    } else {\n        Write-Result -Msg \"Product code not found for uninstall\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI uninstall - $($_.Exception.Message)\" -Success $false\n}\n\n# ============================================================\n# SUMMARY AND SCRIPT ENDING\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case17_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Helper function for log file string search with .Trim()\nfunction Test-LogContains {\n    param(\n        [string]$LogPath,\n        [string]$ExpectedText\n    )\n    $found = $false\n    if (Test-Path $LogPath) {\n        try {\n            $lines = Get-Content $LogPath\n            foreach ($line in $lines) {\n                if ($null -ne $line -and ($line.Trim() -like \"*$ExpectedText*\")) {\n                    $found = $true\n                    break\n                }\n            }\n        } catch {\n            $found = $false\n        }\n    }\n    return $found\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$displayName = \"Microsoft Cloud Managed Desktop Extension\"\n$logFilePath = \"C:\\ProgramData\\Microsoft\\CloudManagedDesktop\\CMDExtension.log\"\n\n# Check if MSI exists\nif (-not (Test-Path $msiPath)) {\n    Write-Host \"ERROR - MSI not found at $msiPath\" -ForegroundColor Red\n    Stop-Transcript\n    exit 2\n}\n\n# Check if service is installed\n$svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n$serviceInstalled = $false\nif ($svc -ne $null) {\n    $serviceInstalled = $true\n    Write-Result -Msg \"Service $serviceName detected\" -Success $true\n} else {\n    Write-Result -Msg \"Service $serviceName not detected\" -Success $false\n}\n\n# ============================================================\n# PHASE 2: INSTALLATION / RESTART\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"PHASE 2: Installation / Service Restart\" -ForegroundColor Cyan\n\n$installNeeded = $false\nif (-not $serviceInstalled) {\n    $installNeeded = $true\n}\n\nif ($installNeeded) {\n    Write-Host \"Installing agent from MSI...\" -ForegroundColor Cyan\n    $installCmd = \"msiexec.exe /i `\"$msiPath`\" SVCENV=Test /qn\"\n    Write-Host \"Executing: $installCmd\" -ForegroundColor Gray\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i\", \"`\"$msiPath`\"\", \"SVCENV=Test\", \"/qn\" -Wait -PassThru\n    $exitCode = $process.ExitCode\n    Write-Host \"MSI install exit code: $exitCode\" -ForegroundColor Gray\n    if (($exitCode -eq 0) -or ($exitCode -eq 3010)) {\n        Write-Result -Msg \"MSI installed successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI install failed (exit code $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 3\n    }\n    # Wait for service to appear\n    $maxWait = 60\n    $waited = 0\n    do {\n        $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n        if ($svc -ne $null) { break }\n        Start-Sleep -Seconds 2\n        $waited += 2\n    } while ($waited -lt $maxWait)\n    if ($svc -eq $null) {\n        Write-Result -Msg \"Service $serviceName not found after install\" -Success $false\n        Stop-Transcript\n        exit 4\n    }\n} else {\n    # Service exists, restart it\n    Write-Host \"Restarting service $serviceName...\" -ForegroundColor Cyan\n    try {\n        Restart-Service -Name $serviceName -Force -ErrorAction Stop\n        Write-Result -Msg \"Service $serviceName restarted\" -Success $true\n    } catch {\n        Write-Result -Msg \"Failed to restart service $serviceName\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n        Stop-Transcript\n        exit 5\n    }\n}\n\n# ============================================================\n# PHASE 3: TEST STEPS\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"PHASE 3: Test Steps\" -ForegroundColor Cyan\n\n# Helper: Create/Enable/Disable/Delete firewall rule\nfunction Ensure-FirewallRule {\n    param(\n        [string]$RuleName,\n        [string]$Direction,\n        [string]$Action,\n        [string]$Protocol,\n        [string]$LocalPort,\n        [string]$Enable = \"True\"\n    )\n    $rule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue\n    if ($rule -eq $null) {\n        # Create rule\n        try {\n            New-NetFirewallRule -DisplayName $RuleName -Direction $Direction -Action $Action -Protocol $Protocol -LocalPort $LocalPort -Enabled $Enable | Out-Null\n            Write-Result -Msg \"Firewall rule '$RuleName' created\" -Success $true\n        } catch {\n            Write-Result -Msg \"Failed to create firewall rule '$RuleName'\" -Success $false\n            Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n        }\n    } else {\n        # Enable/Disable as needed\n        try {\n            Set-NetFirewallRule -DisplayName $RuleName -Enabled $Enable | Out-Null\n            Write-Result -Msg \"Firewall rule '$RuleName' set Enabled=$Enable\" -Success $true\n        } catch {\n            Write-Result -Msg \"Failed to set Enabled=$Enable for rule '$RuleName'\" -Success $false\n            Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n        }\n    }\n}\n\nfunction Remove-FirewallRule {\n    param([string]$RuleName)\n    $rule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue\n    if ($rule -ne $null) {\n        try {\n            Remove-NetFirewallRule -DisplayName $RuleName | Out-Null\n            Write-Result -Msg \"Firewall rule '$RuleName' removed\" -Success $true\n        } catch {\n            Write-Result -Msg \"Failed to remove firewall rule '$RuleName'\" -Success $false\n            Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n        }\n    }\n}\n\n# Step 2: Block TCP 5671 outbound (\"Block amqp\")\nEnsure-FirewallRule -RuleName \"Block amqp\" -Direction Outbound -Action Block -Protocol TCP -LocalPort 5671 -Enable \"True\"\n\n# Step 3: Restart service (already done above if installed, else installed and started)\n\n# Step 4: Check CMDExtension.log for \"DeviceClient created and opened successfully\"\nWrite-Host \"Checking CMDExtension.log for registration success...\" -ForegroundColor Cyan\n$expectedLog1 = \"DeviceClient created and opened successfully\"\n$foundLog1 = Test-LogContains -LogPath $logFilePath -ExpectedText $expectedLog1\nWrite-Result -Msg \"Log contains '$expectedLog1'\" -Success $foundLog1\nif (-not $foundLog1) {\n    Write-Host \"[DEBUG] Log did not contain expected text after step 3\" -ForegroundColor Yellow\n}\n\n# Step 5: Stop service\nWrite-Host \"Stopping service $serviceName...\" -ForegroundColor Cyan\ntry {\n    Stop-Service -Name $serviceName -Force -ErrorAction Stop\n    Write-Result -Msg \"Service $serviceName stopped\" -Success $true\n} catch {\n    Write-Result -Msg \"Failed to stop service $serviceName\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Step 6: Block TCP 443 outbound (\"Block https\")\nEnsure-FirewallRule -RuleName \"Block https\" -Direction Outbound -Action Block -Protocol TCP -LocalPort 443 -Enable \"True\"\n\n# Step 7: Start service and wait 35 minutes\nWrite-Host \"Starting service $serviceName...\" -ForegroundColor Cyan\ntry {\n    Start-Service -Name $serviceName -ErrorAction Stop\n    Write-Result -Msg \"Service $serviceName started\" -Success $true\n} catch {\n    Write-Result -Msg \"Failed to start service $serviceName\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\nWrite-Host \"Waiting 35 minutes for agent to process network block...\" -ForegroundColor Cyan\nStart-Sleep -Seconds (35*60)\n\n# Step 8: Check CMDExtension.log for \"Connect to IoTHub failed with a generic exception\"\n$expectedLog2 = \"Connect to IoTHub failed with a generic exception\"\n$foundLog2 = Test-LogContains -LogPath $logFilePath -ExpectedText $expectedLog2\nWrite-Result -Msg \"Log contains '$expectedLog2' after network block\" -Success $foundLog2\nif (-not $foundLog2) {\n    Write-Host \"[DEBUG] Log did not contain expected text after step 7\" -ForegroundColor Yellow\n}\n\n# Step 9: Disable \"Block https\" rule and wait 10 minutes\nWrite-Host \"Disabling firewall rule 'Block https'...\" -ForegroundColor Cyan\nEnsure-FirewallRule -RuleName \"Block https\" -Direction Outbound -Action Block -Protocol TCP -LocalPort 443 -Enable \"False\"\nWrite-Host \"Waiting 10 minutes after enabling network...\" -ForegroundColor Cyan\nStart-Sleep -Seconds (10*60)\n\n# Step 10: Check CMDExtension.log for \"DeviceClient created and opened successfully\"\n$foundLog3 = Test-LogContains -LogPath $logFilePath -ExpectedText $expectedLog1\nWrite-Result -Msg \"Log contains '$expectedLog1' after network restored\" -Success $foundLog3\nif (-not $foundLog3) {\n    Write-Host \"[DEBUG] Log did not contain expected text after step 9\" -ForegroundColor Yellow\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"PHASE 4: Cleanup\" -ForegroundColor Cyan\n\n# Remove/disable firewall rules \"Block amqp\" and \"Block https\"\nRemove-FirewallRule -RuleName \"Block amqp\"\nRemove-FirewallRule -RuleName \"Block https\"\n\n# Uninstall agent\nWrite-Host \"Uninstalling agent...\" -ForegroundColor Cyan\n$uninstallCmd = \"msiexec.exe /x `\"$msiPath`\" /qn\"\nWrite-Host \"Executing: $uninstallCmd\" -ForegroundColor Gray\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x\", \"`\"$msiPath`\"\", \"/qn\" -Wait -PassThru\n$exitCode = $process.ExitCode\nWrite-Host \"MSI uninstall exit code: $exitCode\" -ForegroundColor Gray\nif (($exitCode -eq 0) -or ($exitCode -eq 3010) -or ($exitCode -eq 1605)) {\n    Write-Result -Msg \"MSI uninstalled successfully (exit code $exitCode)\" -Success $true\n} else {\n    Write-Result -Msg \"MSI uninstall failed (exit code $exitCode)\" -Success $false\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-134714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case8_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Helper function for MSI property reading (per spec)\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI path and service name\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFileName = \"CMDExtension.log\"\n$logPath = Join-Path $logFolder $logFileName\n\n# Check if MSI exists\nif (-not (Test-Path $msiPath)) {\n    Write-Result -Msg \"MSI file not found at $msiPath\" -Success $false\n    Stop-Transcript\n    exit 2\n} else {\n    Write-Result -Msg \"MSI file found at $msiPath\" -Success $true\n}\n\n# Check if product already installed (by service existence)\n$svc = $null\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    if ($svc.Status -eq \"Running\" -or $svc.Status -eq \"Stopped\") {\n        Write-Result -Msg \"Service $serviceName already installed\" -Success $false\n        Write-Host \"[DEBUG] Service status - $($svc.Status)\" -ForegroundColor Yellow\n        Stop-Transcript\n        exit 3\n    }\n} catch {\n    Write-Result -Msg \"Service $serviceName not present - OK to install\" -Success $true\n}\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 4: Run command: msiexec /i cmdextension.msi SVCENV=Test\nWrite-Host \"Installing MSI...\" -ForegroundColor Cyan\n$installCmd = \"msiexec.exe /i `\"$msiPath`\" SVCENV=Test /qn\"\nWrite-Host \"[DEBUG] Executing: $installCmd\" -ForegroundColor Gray\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i\", \"`\"$msiPath`\"\", \"SVCENV=Test\", \"/qn\" -Wait -PassThru\n$exitCode = $process.ExitCode\nWrite-Host \"[DEBUG] msiexec exit code - $exitCode\" -ForegroundColor Gray\n\n# Validate exit code\nif ($exitCode -eq 0 -or $exitCode -eq 3010) {\n    Write-Result -Msg \"MSI installation succeeded (exit code $exitCode)\" -Success $true\n} elseif ($exitCode -eq 1603) {\n    Write-Result -Msg \"MSI installation failed - Fatal error (1603)\" -Success $false\n    Stop-Transcript\n    exit 1603\n} elseif ($exitCode -eq 1618) {\n    Write-Result -Msg \"MSI installation failed - Another installation in progress (1618)\" -Success $false\n    Stop-Transcript\n    exit 1618\n} elseif ($exitCode -eq 1925) {\n    Write-Result -Msg \"MSI installation failed - Insufficient privileges (1925)\" -Success $false\n    Stop-Transcript\n    exit 1925\n} else {\n    Write-Result -Msg \"MSI installation failed - Unknown exit code $exitCode\" -Success $false\n    Stop-Transcript\n    exit $exitCode\n}\n\n# Step 5: Wait 5 minutes and logout (don’t turn off the device)\nWrite-Host \"Waiting 5 minutes after installation...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 300\n\n# Step 6: Wait another 5 minutes and login back\nWrite-Host \"Waiting another 5 minutes after logout/login...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 300\n\n# Step 7: Wait another 5 minutes, logout and login as another user\nWrite-Host \"Waiting another 5 minutes after second logout/login...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 300\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: VERIFICATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 8: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs. \n# Open “CMDExtension.log”\n# Expected: Verify agent was running by below contents’ timestamp.\n# · “Plugin run scheduler with CMDAgentCommunicationChannel:” - should be printed every 20 seconds during logout period.\n\n# Verify log file exists\nif (Test-Path $logPath) {\n    Write-Result -Msg \"Log file $logFileName exists at $logFolder\" -Success $true\n} else {\n    Write-Result -Msg \"Log file $logFileName missing at $logFolder\" -Success $false\n}\n\n# Read log and check for expected message\n$expectedLogMsg = \"Plugin run scheduler with CMDAgentCommunicationChannel:\"\n$logLines = @()\ntry {\n    $logLines = Get-Content -Path $logPath -ErrorAction Stop\n} catch {\n    Write-Result -Msg \"Failed to read log file $logFileName\" -Success $false\n}\n\nif ($logLines.Count -eq 0) {\n    Write-Result -Msg \"Log file $logFileName is empty\" -Success $false\n} else {\n    # Find all lines containing the expected message\n    $matchingLines = $logLines | Where-Object { $_ -like \"*$expectedLogMsg*\" }\n    if ($matchingLines.Count -eq 0) {\n        Write-Result -Msg \"Log does not contain expected message: $expectedLogMsg\" -Success $false\n    } else {\n        Write-Result -Msg \"Log contains expected message: $expectedLogMsg\" -Success $true\n        # Check timestamps for every 20 seconds during logout period\n        # Extract timestamps from matching lines\n        $timestampRegex = '^\\[([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\]'\n        $timestamps = @()\n        foreach ($line in $matchingLines) {\n            if ($line -match $timestampRegex) {\n                $timestamps += $matches[1]\n            }\n        }\n        if ($timestamps.Count -lt 1) {\n            Write-Result -Msg \"No timestamps found in matching log lines\" -Success $false\n        } else {\n            # Calculate intervals between timestamps\n            $dtList = $timestamps | ForEach-Object { [datetime]::ParseExact($_, \"yyyy-MM-dd HH:mm:ss\", $null) }\n            $intervals = @()\n            for ($i=1; $i -lt $dtList.Count; $i++) {\n                $intervals += ($dtList[$i] - $dtList[$i-1]).TotalSeconds\n            }\n            # Check if intervals are close to 20 seconds (+/- 5 seconds tolerance)\n            $allIntervalsOk = $true\n            foreach ($ival in $intervals) {\n                if ($ival -lt 15 -or $ival -gt 25) {\n                    $allIntervalsOk = $false\n                    break\n                }\n            }\n            Write-Result -Msg \"Log message intervals are ~20 seconds during logout period\" -Success $allIntervalsOk\n            if (-not $allIntervalsOk) {\n                Write-Host \"[DEBUG] Intervals found: $($intervals -join ', ')\" -ForegroundColor Yellow\n            }\n        }\n    }\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# Step 9: In the same powershell window as “Step 4”, run command: msiexec /x cmdextension.msi\nWrite-Host \"Uninstalling MSI...\" -ForegroundColor Cyan\n$uninstallCmd = \"msiexec.exe /x `\"$msiPath`\" /qn\"\nWrite-Host \"[DEBUG] Executing: $uninstallCmd\" -ForegroundColor Gray\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x\", \"`\"$msiPath`\"\", \"/qn\" -Wait -PassThru\n$exitCode = $process.ExitCode\nWrite-Host \"[DEBUG] msiexec uninstall exit code - $exitCode\" -ForegroundColor Gray\n\n# Validate uninstall exit code\nif ($exitCode -eq 0 -or $exitCode -eq 3010) {\n    Write-Result -Msg \"MSI uninstall succeeded (exit code $exitCode)\" -Success $true\n} elseif ($exitCode -eq 1605) {\n    Write-Result -Msg \"MSI uninstall failed - Product not installed (1605)\" -Success $false\n} elseif ($exitCode -eq 1603) {\n    Write-Result -Msg \"MSI uninstall failed - Fatal error (1603)\" -Success $false\n} elseif ($exitCode -eq 1618) {\n    Write-Result -Msg \"MSI uninstall failed - Another installation in progress (1618)\" -Success $false\n} elseif ($exitCode -eq 1925) {\n    Write-Result -Msg \"MSI uninstall failed - Insufficient privileges (1925)\" -Success $false\n} else {\n    Write-Result -Msg \"MSI uninstall failed - Unknown exit code $exitCode\" -Success $false\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case1test_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"❌ ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define constants\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFileName = \"CMDExtension.log\"\n$scheduledTaskPath = \"\\Microsoft\\CMD\\Cloud Managed Desktop Extension Health Evaluation\"\n$wmiNamespace = \"root\\cmd\\clientagent\"\n\n# Helper: Get MSI property (do NOT modify this function)\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Helper: Check if product is installed\nfunction Is-ProductInstalled {\n    param([string]$displayName)\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n    )\n    foreach ($regPath in $regPaths) {\n        $keys = Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue\n        foreach ($key in $keys) {\n            $props = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue\n            if ($props.DisplayName -and ($props.DisplayName.Trim() -eq $displayName)) {\n                return $true\n            }\n        }\n    }\n    return $false\n}\n\n# Pre-check: MSI file exists\nif (-not (Test-Path $msiPath)) {\n    Write-Host \"❌ ERROR - MSI file not found at $msiPath\" -ForegroundColor Red\n    Stop-Transcript\n    exit 2\n}\nWrite-Result -Msg \"MSI file found at $msiPath\" -Success $true\n\n# Pre-check: Product not already installed\nif (Is-ProductInstalled -displayName $productName) {\n    Write-Host \"❌ ERROR - Product '$productName' is already installed. Uninstall before running this test.\" -ForegroundColor Red\n    Stop-Transcript\n    exit 3\n}\nWrite-Result -Msg \"Product '$productName' not installed (ready for test)\" -Success $true\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n$installLog = Join-Path $logDir \"install_case1test_$timestamp.log\"\n$msiExecCmd = \"msiexec.exe /i `\"$msiPath`\" /qn /l*v `\"$installLog`\"\"\nWrite-Host \"Installing MSI silently...\" -ForegroundColor Cyan\n\ntry {\n    $process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiPath`\" /qn /l*v `\"$installLog`\"\" -Wait -PassThru -WindowStyle Hidden\n    $exitCode = $process.ExitCode\n    Write-Host \"MSIExec exit code: $exitCode\" -ForegroundColor Gray\n} catch {\n    Write-Result -Msg \"MSI installation process failed to start\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 4\n}\n\n# Exit code handling\n$successCodes = @(0, 3010)\nif ($successCodes -contains $exitCode) {\n    Write-Result -Msg \"MSI installation succeeded (exit code $exitCode)\" -Success $true\n} elseif ($exitCode -eq 1603) {\n    Write-Result -Msg \"MSI installation failed (exit code 1603 - installation failure)\" -Success $false\n    Stop-Transcript\n    exit 1603\n} elseif ($exitCode -eq 1618) {\n    Write-Result -Msg \"MSI installation failed (exit code 1618 - another installation in progress)\" -Success $false\n    Stop-Transcript\n    exit 1618\n} elseif ($exitCode -eq 1925) {\n    Write-Result -Msg \"MSI installation failed (exit code 1925 - insufficient privileges)\" -Success $false\n    Stop-Transcript\n    exit 1925\n} else {\n    Write-Result -Msg \"MSI installation failed (exit code $exitCode)\" -Success $false\n    Stop-Transcript\n    exit $exitCode\n}\n\n# Wait for service to appear (max 30s)\n$maxWait = 30\n$waited = 0\nwhile ($waited -lt $maxWait) {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($svc) { break }\n    Start-Sleep -Seconds 2\n    $waited += 2\n}\nif ($svc) {\n    Write-Result -Msg \"Service '$serviceName' detected after install\" -Success $true\n} else {\n    Write-Result -Msg \"Service '$serviceName' NOT detected after install\" -Success $false\n}\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: VERIFICATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n# 1. Verify product in installed programs (registry)\n$foundProduct = $false\n$regPaths = @(\n    \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n)\nforeach ($regPath in $regPaths) {\n    $keys = Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue\n    foreach ($key in $keys) {\n        $props = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue\n        if ($props.DisplayName -and ($props.DisplayName.Trim() -eq $productName)) {\n            $foundProduct = $true\n            break\n        }\n    }\n    if ($foundProduct) { break }\n}\nWrite-Result -Msg \"Installed programs contains '$productName'\" -Success $foundProduct\nif (-not $foundProduct) {\n    Write-Host \"[DEBUG] '$productName' not found in registry uninstall keys\" -ForegroundColor Yellow\n}\n\n# 2. Verify service running\n$svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif ($svc) {\n    $isRunning = ($svc.Status -eq \"Running\")\n    Write-Result -Msg \"Service '$serviceName' is running\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Service status: $($svc.Status)\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"Service '$serviceName' not found\" -Success $false\n}\n\n# 3. Verify service properties (WMI)\n$svcWmi = Get-WmiObject Win32_Service -Filter \"Name='$serviceName'\" -ErrorAction SilentlyContinue\nif ($svcWmi) {\n    # Status\n    $status = $svcWmi.State\n    $isRunning = ($status.Trim() -eq \"Running\")\n    Write-Result -Msg \"Service '$serviceName' WMI State is 'Running'\" -Success $isRunning\n    if (-not $isRunning) {\n        Write-Host \"[DEBUG] Expected: 'Running', Actual: '$status'\" -ForegroundColor Yellow\n    }\n    # Startup Type\n    $startMode = $svcWmi.StartMode\n    $expectedStartMode = \"Delayed Auto\"\n    $isStartMode = ($startMode.Trim() -eq $expectedStartMode)\n    Write-Result -Msg \"Service '$serviceName' Startup Type is '$expectedStartMode'\" -Success $isStartMode\n    if (-not $isStartMode) {\n        Write-Host \"[DEBUG] Expected: '$expectedStartMode', Actual: '$startMode'\" -ForegroundColor Yellow\n    }\n    # Log On As\n    $logon = $svcWmi.StartName\n    $expectedLogon = \"LocalSystem\"\n    $isLogon = ($logon.Trim() -eq $expectedLogon)\n    Write-Result -Msg \"Service '$serviceName' Log On As is '$expectedLogon'\" -Success $isLogon\n    if (-not $isLogon) {\n        Write-Host \"[DEBUG] Expected: '$expectedLogon', Actual: '$logon'\" -ForegroundColor Yellow\n    }\n} else {\n    Write-Result -Msg \"Service '$serviceName' not found in WMI\" -Success $false\n}\n\n# 4. Verify log file exists\n$logFilePath = Join-Path $logFolder $logFileName\n$logExists = Test-Path $logFilePath\nWrite-Result -Msg \"Log file '$logFileName' exists in $logFolder\" -Success $logExists\nif (-not $logExists) {\n    Write-Host \"[DEBUG] Log file path: $logFilePath\" -ForegroundColor Yellow\n}\n\n# 5. Verify scheduled task exists\ntry {\n    $task = Get-ScheduledTask -TaskPath \"\\Microsoft\\CMD\\\" -TaskName \"Cloud Managed Desktop Extension Health Evaluation\" -ErrorAction SilentlyContinue\n    $taskExists = ($task -ne $null)\n    Write-Result -Msg \"Scheduled task 'Cloud Managed Desktop Extension Health Evaluation' exists\" -Success $taskExists\n    if (-not $taskExists) {\n        Write-Host \"[DEBUG] Scheduled task not found at $scheduledTaskPath\" -ForegroundColor Yellow\n    }\n} catch {\n    Write-Result -Msg \"Scheduled task query failed\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# 6. Verify WMI namespace exists (no \"Invalid namespace\" error)\ntry {\n    $wmiObj = Get-WmiObject -Namespace $wmiNamespace -Class \"__Namespace\" -ErrorAction Stop\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' is accessible (no error)\" -Success $true\n} catch {\n    Write-Result -Msg \"WMI namespace '$wmiNamespace' is NOT accessible (Invalid namespace)\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nWrite-Host \"Uninstalling product...\" -ForegroundColor Cyan\ntry {\n    $uninstallProcess = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn /l*v `\"$installLog`\"\" -Wait -PassThru -WindowStyle Hidden\n    $uninstallExit = $uninstallProcess.ExitCode\n    Write-Host \"MSIExec uninstall exit code: $uninstallExit\" -ForegroundColor Gray\n} catch {\n    Write-Result -Msg \"MSI uninstall process failed to start\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 5\n}\n\n# Uninstall exit code handling\nif ($successCodes -contains $uninstallExit) {\n    Write-Result -Msg \"MSI uninstall succeeded (exit code $uninstallExit)\" -Success $true\n} elseif ($uninstallExit -eq 1605) {\n    Write-Result -Msg \"MSI uninstall failed (exit code 1605 - product not installed)\" -Success $false\n} else {\n    Write-Result -Msg \"MSI uninstall failed (exit code $uninstallExit)\" -Success $false\n}\n\n# Verify service removed\n$svcAfter = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n$svcRemoved = ($svcAfter -eq $null)\nWrite-Result -Msg \"Service '$serviceName' removed after uninstall\" -Success $svcRemoved\nif (-not $svcRemoved) {\n    Write-Host \"[DEBUG] Service still present after uninstall\" -ForegroundColor Yellow\n}\n\n# Verify product removed from installed programs\n$productRemoved = -not (Is-ProductInstalled -displayName $productName)\nWrite-Result -Msg \"Product '$productName' removed from installed programs\" -Success $productRemoved\nif (-not $productRemoved) {\n    Write-Host \"[DEBUG] Product still present in registry uninstall keys after uninstall\" -ForegroundColor Yellow\n}\n\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case2test_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"[FAIL] ERROR: Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI path and product/service names\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$installFolder_x64 = \"C:\\Program Files\\Microsoft Cloud Managed Desktop Extension\"\n$installFolder_x86 = \"C:\\Program Files (x86)\\Microsoft Cloud Managed Desktop Extension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFilePath = Join-Path $logFolder \"CMDExtension.log\"\n$agentLogPath = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\\InfraLogs\\AgentMainService.log\"\n$scheduledTaskName = \"Cloud Managed Desktop Extension Health Evaluation\"\n$scheduledTaskPath = \"\\Microsoft\\CMD\\$scheduledTaskName\"\n$wmiNamespace = \"root\\cmd\\clientagent\"\n$regPath_x64 = \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\"\n$regPath_x86 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\"\n\n# Check if product is already installed\nfunction Get-ProductCode {\n    param([string]$msiFile)\n    $msi = New-Object -ComObject WindowsInstaller.Installer\n    $db = $msi.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $msi, @($msiFile, 0))\n    $view = $db.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $db, @(\"SELECT * FROM Property WHERE Property = 'ProductCode'\"))\n    $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n    $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n    if ($record -ne $null) {\n        $productCode = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 2)\n        return $productCode\n    }\n    return $null\n}\n\n$productCode = Get-ProductCode -msiFile $msiPath\n$alreadyInstalled = $false\nif ($productCode) {\n    $installed = Get-WmiObject -Class Win32_Product | Where-Object { $_.IdentifyingNumber -eq $productCode }\n    if ($installed) {\n        $alreadyInstalled = $true\n        Write-Result -Msg \"Product already installed: $productName ($productCode)\" -Success $false\n        Write-Host \"Attempting to uninstall before test...\" -ForegroundColor Yellow\n        $uninstallCmd = \"msiexec.exe /x $productCode /qn\"\n        $uninstallProc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x $productCode /qn\" -Wait -PassThru\n        if ($uninstallProc.ExitCode -eq 0 -or $uninstallProc.ExitCode -eq 1605) {\n            Write-Result -Msg \"Pre-existing product uninstalled successfully.\" -Success $true\n        } else {\n            Write-Result -Msg \"Failed to uninstall pre-existing product. Exit code: $($uninstallProc.ExitCode)\" -Success $false\n            Stop-Transcript\n            exit 1\n        }\n    } else {\n        Write-Result -Msg \"Product not installed. Ready for test.\" -Success $true\n    }\n} else {\n    Write-Result -Msg \"Could not determine ProductCode from MSI. Proceeding with install.\" -Success $true\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing $productName from $msiPath ...\" -ForegroundColor Cyan\n\n$installCmd = \"msiexec.exe /i `\"$msiPath`\" /qn\"\ntry {\n    $installProc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiPath`\" /qn\" -Wait -PassThru\n    $exitCode = $installProc.ExitCode\n    if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n        Write-Result -Msg \"MSI installation succeeded. Exit code: $exitCode\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI installation failed. Exit code: $exitCode\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI installation: $_\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for service to start (if applicable)\nStart-Sleep -Seconds 120\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"Verifying installation artifacts...\" -ForegroundColor Cyan\n\n# 1. Service running?\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($svc -and $svc.Status -eq \"Running\") {\n        Write-Result -Msg \"Service '$serviceName' is running.\" -Success $true\n    } elseif ($svc) {\n        Write-Result -Msg \"Service '$serviceName' exists but is not running.\" -Success $false\n    } else {\n        Write-Result -Msg \"Service '$serviceName' not found.\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Error checking service '$serviceName': $_\" -Success $false\n}\n\n# 2. Service properties\ntry {\n    $svcWmi = Get-WmiObject -Class Win32_Service -Filter \"Name='$serviceName'\" -ErrorAction SilentlyContinue\n    if ($svcWmi) {\n        Write-Result -Msg \"Service '$serviceName' properties found.\" -Success $true\n    } else {\n        Write-Result -Msg \"Service '$serviceName' properties not found.\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Error querying Win32_Service for '$serviceName': $_\" -Success $false\n}\n\n# 3. Files created?\n$folderExists_x64 = Test-Path $installFolder_x64\n$folderExists_x86 = Test-Path $installFolder_x86\nif ($folderExists_x64 -or $folderExists_x86) {\n    Write-Result -Msg \"Install folder exists.\" -Success $true\n} else {\n    Write-Result -Msg \"Install folder does not exist.\" -Success $false\n}\n\nif (Test-Path $logFilePath) {\n    Write-Result -Msg \"CMDExtension.log exists at $logFilePath.\" -Success $true\n} else {\n    Write-Result -Msg \"CMDExtension.log missing at $logFilePath.\" -Success $false\n}\n\nif (Test-Path $agentLogPath) {\n    Write-Result -Msg \"AgentMainService.log exists at $agentLogPath.\" -Success $true\n} else {\n    Write-Result -Msg \"AgentMainService.log missing at $agentLogPath.\" -Success $false\n}\n\n# 4. Registry entries\n$regExists_x64 = Test-Path $regPath_x64\n$regExists_x86 = Test-Path $regPath_x86\nif ($regExists_x64 -or $regExists_x86) {\n    Write-Result -Msg \"Registry key for CloudManagementDesktop exists.\" -Success $true\n} else {\n    Write-Result -Msg \"Registry key for CloudManagementDesktop does not exist.\" -Success $false\n}\n\n# 5. Scheduled tasks\ntry {\n    $task = Get-ScheduledTask -TaskPath \"\\Microsoft\\CMD\\\" -TaskName $scheduledTaskName -ErrorAction SilentlyContinue\n    if ($task) {\n        Write-Result -Msg \"Scheduled task '$scheduledTaskName' exists.\" -Success $true\n    } else {\n        Write-Result -Msg \"Scheduled task '$scheduledTaskName' not found.\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Error querying scheduled task: $_\" -Success $false\n}\n\n# 6. WMI namespace\ntry {\n    $wmiTest = Get-WmiObject -Namespace $wmiNamespace -Class \"__Namespace\" -ErrorAction SilentlyContinue\n    if ($wmiTest) {\n        Write-Result -Msg \"WMI namespace '$wmiNamespace' exists.\" -Success $true\n    } else {\n        Write-Result -Msg \"WMI namespace '$wmiNamespace' not found.\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Error querying WMI namespace '$wmiNamespace': $_\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"Uninstalling $productName ...\" -ForegroundColor Cyan\n\ntry {\n    $uninstallProc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru\n    $uninstallExit = $uninstallProc.ExitCode\n    if ($uninstallExit -eq 0 -or $uninstallExit -eq 1605) {\n        Write-Result -Msg \"MSI uninstallation succeeded. Exit code: $uninstallExit\" -Success $true\n    } elseif ($uninstallExit -eq 3010) {\n        Write-Result -Msg \"MSI uninstallation succeeded (reboot required). Exit code: $uninstallExit\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI uninstallation failed. Exit code: $uninstallExit\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI uninstallation: $_\" -Success $false\n}\n\nStart-Sleep -Seconds 10\n\nWrite-Host \"\"\nWrite-Host \"Verifying cleanup...\" -ForegroundColor Cyan\n\n# 1. Service removed\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if ($svc) {\n        Write-Result -Msg \"Service '$serviceName' still exists after uninstall.\" -Success $false\n    } else {\n        Write-Result -Msg \"Service '$serviceName' removed after uninstall.\" -Success $true\n    }\n} catch {\n    Write-Result -Msg \"Error checking service after uninstall: $_\" -Success $false\n}\n\n# 2. Install folder removed\n$folderExists_x64 = Test-Path $installFolder_x64\n$folderExists_x86 = Test-Path $installFolder_x86\nif (-not $folderExists_x64 -and -not $folderExists_x86) {\n    Write-Result -Msg \"Install folder removed after uninstall.\" -Success $true\n} else {\n    Write-Result -Msg \"Install folder still exists after uninstall.\" -Success $false\n}\n\n# 3. Registry key removed\n$regExists_x64 = Test-Path $regPath_x64\n$regExists_x86 = Test-Path $regPath_x86\nif (-not $regExists_x64 -and -not $regExists_x86) {\n    Write-Result -Msg \"Registry key removed after uninstall.\" -Success $true\n} else {\n    Write-Result -Msg \"Registry key still exists after uninstall.\" -Success $false\n}\n\n# 4. Scheduled task removed\ntry {\n    $task = Get-ScheduledTask -TaskPath \"\\Microsoft\\CMD\\\" -TaskName $scheduledTaskName -ErrorAction SilentlyContinue\n    if ($task) {\n        Write-Result -Msg \"Scheduled task '$scheduledTaskName' still exists after uninstall.\" -Success $false\n    } else {\n        Write-Result -Msg \"Scheduled task '$scheduledTaskName' removed after uninstall.\" -Success $true\n    }\n} catch {\n    Write-Result -Msg \"Error querying scheduled task after uninstall: $_\" -Success $false\n}\n\n# 5. WMI namespace removed\ntry {\n    $wmiTest = Get-WmiObject -Namespace $wmiNamespace -Class \"__Namespace\" -ErrorAction SilentlyContinue\n    if ($wmiTest) {\n        Write-Result -Msg \"WMI namespace '$wmiNamespace' still exists after uninstall.\" -Success $false\n    } else {\n        Write-Result -Msg \"WMI namespace '$wmiNamespace' removed after uninstall.\" -Success $true\n    }\n} catch {\n    Write-Result -Msg \"Error querying WMI namespace after uninstall: $_\" -Success $false\n}\n\n# 6. CMDExtension.log should still be present\nif (Test-Path $logFilePath) {\n    Write-Result -Msg \"CMDExtension.log still present after uninstall.\" -Success $true\n} else {\n    Write-Result -Msg \"CMDExtension.log missing after uninstall.\" -Success $false\n}\n\n# 7. AgentMainService.log should contain \"Service is on OnStop\"\nif (Test-Path $agentLogPath) {\n    $logContent = Get-Content $agentLogPath -ErrorAction SilentlyContinue\n    if ($logContent -match \"Service is on OnStop\") {\n        Write-Result -Msg \"AgentMainService.log contains 'Service is on OnStop'.\" -Success $true\n    } else {\n        Write-Result -Msg \"AgentMainService.log does NOT contain 'Service is on OnStop'.\" -Success $false\n    }\n} else {\n    Write-Result -Msg \"AgentMainService.log missing after uninstall.\" -Success $false\n}\n\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$test_case_id = \"case4test\"\n$logFile = Join-Path $logDir \"test_${test_case_id}_$timestamp.log\"\n\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"ERROR - Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI path and product/service names\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFolder = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFilePath = Join-Path $logFolder \"CMDExtension.log\"\n\n# Registry paths for x86/x64\n$regPath_x86 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n$regPath_x64 = \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n\n# Helper: Get MSI property (per instructions)\nfunction Get-MSIProperty {\n    param(\n        [string]$msiPath,\n        [string]$property\n    )\n    try {\n        $installer = New-Object -ComObject WindowsInstaller.Installer\n        $database = $installer.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $installer, @($msiPath, 0))\n        $query = \"SELECT Value FROM Property WHERE Property = '$property'\"\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, ($query))\n        $null = $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        $value = $null\n        if ($record -ne $null) {\n            $value = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 1)\n        }\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($view)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($database)\n        $null = [System.Runtime.InteropServices.Marshal]::ReleaseComObject($installer)\n        if ([string]::IsNullOrWhiteSpace($value)) {\n            return $null\n        }\n        return $value.Trim()\n    } catch {\n        Write-Host \"[DEBUG] Get-MSIProperty failed for property '$property' - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Helper: Find cert by subject/issuer\nfunction Find-DeviceCert {\n    param(\n        [string]$subject\n    )\n    try {\n        $store = New-Object System.Security.Cryptography.X509Certificates.X509Store(\"My\",\"LocalMachine\")\n        $store.Open(\"ReadWrite\")\n        $found = $store.Certificates | Where-Object {\n            ($_.Subject -like \"*$subject*\") -and ($_.Issuer -like \"*$subject*\")\n        }\n        $store.Close()\n        return $found\n    } catch {\n        Write-Host \"[DEBUG] Find-DeviceCert failed - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $null\n    }\n}\n\n# Helper: Delete cert by subject/issuer\nfunction Delete-DeviceCert {\n    param(\n        [string]$subject\n    )\n    try {\n        $store = New-Object System.Security.Cryptography.X509Certificates.X509Store(\"My\",\"LocalMachine\")\n        $store.Open(\"ReadWrite\")\n        $toDelete = $store.Certificates | Where-Object {\n            ($_.Subject -like \"*$subject*\") -and ($_.Issuer -like \"*$subject*\")\n        }\n        foreach ($cert in $toDelete) {\n            $store.Remove($cert)\n        }\n        $store.Close()\n        return $toDelete.Count\n    } catch {\n        Write-Host \"[DEBUG] Delete-DeviceCert failed - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return 0\n    }\n}\n\n# Helper: Restart service and wait for running\nfunction Restart-ServiceAndWait {\n    param([string]$svcName, [int]$waitSec = 30)\n    try {\n        Restart-Service -Name $svcName -Force\n        Write-Host \"Waiting $waitSec seconds for service registration...\" -ForegroundColor Gray\n        Start-Sleep -Seconds $waitSec\n        $svc = Get-Service -Name $svcName -ErrorAction SilentlyContinue\n        if ($svc -and ($svc.Status -eq \"Running\")) {\n            return $true\n        } else {\n            return $false\n        }\n    } catch {\n        Write-Host \"[DEBUG] Restart-ServiceAndWait failed - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $false\n    }\n}\n\n# Helper: Search log for strings\nfunction Search-Log {\n    param(\n        [string]$logPath,\n        [string[]]$mustContain,\n        [string[]]$mustNotContain\n    )\n    $exists = Test-Path $logPath\n    if (-not $exists) {\n        Write-Result -Msg \"Log file $logPath exists\" -Success $false\n        return $false\n    }\n    $content = Get-Content $logPath -Raw\n    $allFound = $true\n    foreach ($str in $mustContain) {\n        $found = $content -like \"*$str*\"\n        Write-Result -Msg \"Log contains '$str'\" -Success $found\n        if (-not $found) {\n            Write-Host \"[DEBUG] Log missing expected string - '$str'\" -ForegroundColor Yellow\n            $allFound = $false\n        }\n    }\n    foreach ($str in $mustNotContain) {\n        $found = $content -like \"*$str*\"\n        Write-Result -Msg \"Log does NOT contain '$str'\" -Success (-not $found)\n        if ($found) {\n            Write-Host \"[DEBUG] Log contains unexpected string - '$str'\" -ForegroundColor Yellow\n            $allFound = $false\n        }\n    }\n    return $allFound\n}\n\n# Helper: WMI instance check\nfunction Check-WMIInstances {\n    param(\n        [string]$namespace,\n        [string]$class\n    )\n    try {\n        $instances = Get-WmiObject -Namespace $namespace -Class $class -ErrorAction Stop\n        $count = ($instances | Measure-Object).Count\n        $notEmpty = ($count -gt 0)\n        Write-Result -Msg \"WMI $namespace\\$class instance count > 0\" -Success $notEmpty\n        if (-not $notEmpty) {\n            Write-Host \"[DEBUG] WMI instance count: $count\" -ForegroundColor Yellow\n        }\n        return $notEmpty\n    } catch {\n        Write-Result -Msg \"WMI $namespace\\$class query failed\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n        return $false\n    }\n}\n\n# Helper: Registry check for DeviceRegistrationType\nfunction Get-DeviceRegistrationType {\n    foreach ($regPath in @($regPath_x64, $regPath_x86)) {\n        if (Test-Path $regPath) {\n            try {\n                $val = (Get-ItemProperty -Path $regPath -Name \"DeviceRegistrationType\" -ErrorAction Stop).DeviceRegistrationType\n                if (-not [string]::IsNullOrWhiteSpace($val)) {\n                    return $val.Trim()\n                }\n            } catch {}\n        }\n    }\n    return $null\n}\n\n# Helper: Wait for service running\nfunction Wait-ForService {\n    param([string]$svcName, [int]$timeoutSec = 60)\n    $svc = $null\n    $elapsed = 0\n    while ($elapsed -lt $timeoutSec) {\n        $svc = Get-Service -Name $svcName -ErrorAction SilentlyContinue\n        if ($svc -and ($svc.Status -eq \"Running\")) {\n            Write-Result -Msg \"Service $svcName is running\" -Success $true\n            return $true\n        }\n        Start-Sleep -Seconds 2\n        $elapsed += 2\n    }\n    Write-Result -Msg \"Service $svcName is running\" -Success $false\n    return $false\n}\n\n# Check if already installed (service exists)\n$svcPre = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif ($svcPre) {\n    Write-Host \"Product already installed. Uninstalling before test...\" -ForegroundColor Yellow\n    try {\n        $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru).ExitCode\n        Write-Result -Msg \"Pre-test uninstall exit code = $exitCode\" -Success ($exitCode -eq 0 -or $exitCode -eq 1605)\n        Start-Sleep -Seconds 5\n    } catch {\n        Write-Result -Msg \"Pre-test uninstall command threw exception\" -Success $false\n        Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    }\n}\n\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 2: INSTALLATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n$installCmd = \"msiexec /i `\"$msiPath`\" SVCENV=Test /qn\"\nWrite-Host \"Installing product...\" -ForegroundColor Cyan\ntry {\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiPath`\" SVCENV=Test /qn\" -Wait -PassThru).ExitCode\n    $success = ($exitCode -eq 0 -or $exitCode -eq 3010)\n    Write-Result -Msg \"Install exit code = $exitCode\" -Success $success\n    if (-not $success) {\n        Write-Host \"Install failed with exit code $exitCode. Aborting test.\" -ForegroundColor Red\n        Stop-Transcript\n        exit 2\n    }\n} catch {\n    Write-Result -Msg \"Install command threw exception\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n    Stop-Transcript\n    exit 2\n}\n\n# Wait for service to start (up to 60s)\nWait-ForService -svcName $serviceName -timeoutSec 60\n\n# Wait 5 minutes for agent registration (per scenario)\nWrite-Host \"Waiting 5 minutes for agent registration...\" -ForegroundColor Cyan\nStart-Sleep -Seconds 300\n\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 3: VERIFICATION\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\n$skipCertSteps = $false\n\n# Step 5: Check log for registration success/failure\n$mustContain = @(\"DeviceClient created and opened successfully\")\n$mustNotContain = @(\"Failed to create instance for plugin\")\nSearch-Log -logPath $logFilePath -mustContain $mustContain -mustNotContain $mustNotContain\n\n# Step 6: WMI instance check\nCheck-WMIInstances -namespace \"root\\cmd\\clientagent\" -class \"SchedulerEntity\"\n\n# Step 7: Registry DeviceRegistrationType\n$regType = Get-DeviceRegistrationType\nif ($null -eq $regType -or [string]::IsNullOrWhiteSpace($regType)) {\n    Write-Result -Msg \"DeviceRegistrationType registry value found\" -Success $false\n    Write-Host \"[DEBUG] Actual value: $regType\" -ForegroundColor Yellow\n    $skipCertSteps = $true\n} else {\n    $regTypeTrimmed = $regType.Trim()\n    $isCert = ($regTypeTrimmed -eq \"Certificate\")\n    Write-Result -Msg \"DeviceRegistrationType is 'Certificate'\" -Success $isCert\n    if (-not $isCert) {\n        Write-Host \"DeviceRegistrationType is not 'Certificate'. Skipping cert deletion test.\" -ForegroundColor Yellow\n        $skipCertSteps = $true\n    }\n}\n\nif (-not $skipCertSteps) {\n    # Step 9: Find device cert (simulate {tenantId.aadDeviceId} as subject)\n    # For automation, use a pattern (e.g., \"CN=\" prefix)\n    $subjectPattern = \"CN=\"\n    $foundCerts = Find-DeviceCert -subject $subjectPattern\n    $certExists = ($foundCerts -and $foundCerts.Count -gt 0)\n    Write-Result -Msg \"Device certificate exists before deletion\" -Success $certExists\n    if (-not $certExists) {\n        Write-Host \"[DEBUG] No device certificate found before deletion.\" -ForegroundColor Yellow\n    }\n\n    # Step 10: Delete cert\n    $deletedCount = Delete-DeviceCert -subject $subjectPattern\n    Write-Result -Msg \"Device certificate deleted\" -Success ($deletedCount -gt 0)\n    if ($deletedCount -eq 0) {\n        Write-Host \"[DEBUG] No device certificate deleted.\" -ForegroundColor Yellow\n    }\n\n    # Step 11: Restart service\n    $svcRestarted = Restart-ServiceAndWait -svcName $serviceName\n    Write-Result -Msg \"Service restarted and running\" -Success $svcRestarted\n\n    # Step 12: Check log for post-restart registration\n    $mustContain2 = @(\"Clear iot connection info success\", \"RegisterDeviceToHermesAsync starts\", \"DeviceClient created and opened successfully\")\n    Search-Log -logPath $logFilePath -mustContain $mustContain2 -mustNotContain @()\n\n    # Step 13: Cert re-created\n    $foundCerts2 = Find-DeviceCert -subject $subjectPattern\n    $certExists2 = ($foundCerts2 -and $foundCerts2.Count -gt 0)\n    Write-Result -Msg \"Device certificate re-created after restart\" -Success $certExists2\n    if (-not $certExists2) {\n        Write-Host \"[DEBUG] Device certificate not re-created after restart.\" -ForegroundColor Yellow\n    }\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"PHASE 4: CLEANUP\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nWrite-Host \"Uninstalling product...\" -ForegroundColor Cyan\ntry {\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru).ExitCode\n    $success = ($exitCode -eq 0 -or $exitCode -eq 1605)\n    Write-Result -Msg \"Uninstall exit code = $exitCode\" -Success $success\n    Start-Sleep -Seconds 5\n} catch {\n    Write-Result -Msg \"Uninstall command threw exception\" -Success $false\n    Write-Host \"[DEBUG] Exception - $($_.Exception.Message)\" -ForegroundColor Yellow\n}\n\n# Verify service removed\n$svcPost = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nWrite-Result -Msg \"Service $serviceName removed after uninstall\" -Success (-not $svcPost)\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$test_case_id = \"case10test\"\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_${test_case_id}_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n# Helper function for result tracking\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"[FAIL] Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n} else {\n    Write-Result -Msg \"Running as Administrator\" -Success $true\n}\n\n# Define MSI paths and product/service names\n$msiPathV1 = \"C:\\VMShare\\cmdextension.v1.msi\"\n$msiPathV2 = \"C:\\VMShare\\cmdextension.v2.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n\n# Check if MSI files exist\nif (-not (Test-Path $msiPathV1)) {\n    Write-Result -Msg \"MSI v1 file not found: $msiPathV1\" -Success $false\n    Stop-Transcript\n    exit 1\n}\nif (-not (Test-Path $msiPathV2)) {\n    Write-Result -Msg \"MSI v2 file not found: $msiPathV2\" -Success $false\n    Stop-Transcript\n    exit 1\n}\nWrite-Result -Msg \"Both MSI files found\" -Success $true\n\n# Check if product is already installed (by DisplayName)\nfunction Get-InstalledProductVersion {\n    param([string]$displayName)\n    $regPaths = @(\n        \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n        \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n    )\n    foreach ($regPath in $regPaths) {\n        $keys = Get-ChildItem $regPath -ErrorAction SilentlyContinue\n        foreach ($key in $keys) {\n            $props = Get-ItemProperty $key.PSPath -ErrorAction SilentlyContinue\n            if ($props.DisplayName -eq $displayName) {\n                return $props.DisplayVersion\n            }\n        }\n    }\n    return $null\n}\n\n$currentVersion = Get-InstalledProductVersion -displayName $productName\nif ($currentVersion) {\n    Write-Result -Msg \"$productName already installed (version: $currentVersion)\" -Success $true\n} else {\n    Write-Result -Msg \"$productName not currently installed\" -Success $true\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing v2 (latest)...\" -ForegroundColor Cyan\n\n$installV2Args = \"/i `\"$msiPathV2`\" /qn /norestart\"\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $installV2Args -Wait -PassThru\n$exitCodeV2 = $process.ExitCode\n\nif ($exitCodeV2 -eq 0 -or $exitCodeV2 -eq 3010) {\n    Write-Result -Msg \"v2 MSI installed successfully (exit code: $exitCodeV2)\" -Success $true\n} else {\n    Write-Result -Msg \"v2 MSI installation failed (exit code: $exitCodeV2)\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for service to start (if applicable)\nStart-Sleep -Seconds 10\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    if ($svc.Status -eq 'Running') {\n        Write-Result -Msg \"Service '$serviceName' is running after v2 install\" -Success $true\n    } else {\n        Write-Result -Msg \"Service '$serviceName' is NOT running after v2 install (status: $($svc.Status))\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Service '$serviceName' not found after v2 install\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 3: DOWNGRADE ATTEMPT & VERIFICATION\n# ============================================================\nWrite-Host \"Attempting downgrade: Installing v1 over v2...\" -ForegroundColor Cyan\n\n$installV1Args = \"/i `\"$msiPathV1`\" /qn\"\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $installV1Args -Wait -PassThru\n$exitCodeV1 = $process.ExitCode\n\n# According to scenario, downgrade should fail, but /qn is silent, so we only check exit code\nif ($exitCodeV1 -eq 1603) {\n    Write-Result -Msg \"v1 MSI downgrade attempt failed as expected (exit code: $exitCodeV1)\" -Success $true\n} elseif ($exitCodeV1 -eq 0 -or $exitCodeV1 -eq 3010) {\n    Write-Result -Msg \"v1 MSI downgrade unexpectedly succeeded (exit code: $exitCodeV1)\" -Success $false\n} else {\n    Write-Result -Msg \"v1 MSI downgrade attempt returned exit code: $exitCodeV1\" -Success $false\n}\n\n# Wait for a moment to ensure state is stable\nStart-Sleep -Seconds 10\n\n# Verify product version is still v2\n$installedVersion = Get-InstalledProductVersion -displayName $productName\nif ($installedVersion) {\n    # Extract expected v2 version from MSI (optional: get from MSI file, but not required by scenario)\n    # For this script, just check that version is not downgraded\n    $expectedVersion = $installedVersion # In real test, parse v2 version from MSI if needed\n    Write-Result -Msg \"$productName is present in installed programs (version: $installedVersion)\" -Success $true\n    # If you know v2 version number, compare here\n    # Example: if ($installedVersion -eq \"2.0.0.0\") { ... }\n} else {\n    Write-Result -Msg \"$productName is NOT present in installed programs after downgrade attempt\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"Cleaning up: Uninstalling v2...\" -ForegroundColor Cyan\n\n$uninstallV2Args = \"/x `\"$msiPathV2`\" /qn /norestart\"\n$process = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $uninstallV2Args -Wait -PassThru\n$exitCodeUninstall = $process.ExitCode\n\nif ($exitCodeUninstall -eq 0 -or $exitCodeUninstall -eq 3010) {\n    Write-Result -Msg \"v2 MSI uninstalled successfully (exit code: $exitCodeUninstall)\" -Success $true\n} elseif ($exitCodeUninstall -eq 1605) {\n    Write-Result -Msg \"v2 MSI uninstall: product not installed (exit code: $exitCodeUninstall)\" -Success $true\n} else {\n    Write-Result -Msg \"v2 MSI uninstall failed (exit code: $exitCodeUninstall)\" -Success $false\n}\n\n# Verify service is removed\ntry {\n    $svc = Get-Service -Name $serviceName -ErrorAction Stop\n    Write-Result -Msg \"Service '$serviceName' still present after uninstall\" -Success $false\n} catch {\n    Write-Result -Msg \"Service '$serviceName' removed after uninstall\" -Success $true\n}\n\n# Verify product is no longer installed\n$finalVersion = Get-InstalledProductVersion -displayName $productName\nif ($finalVersion) {\n    Write-Result -Msg \"$productName still present after uninstall (version: $finalVersion)\" -Success $false\n} else {\n    Write-Result -Msg \"$productName removed from installed programs after uninstall\" -Success $true\n}\n\nWrite-Host \"\"\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$logFile = Join-Path $logDir \"test_case11test_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n# Helper function for result tracking\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"[FAIL] ERROR: Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI paths and product/service names\n$msiV1Path = \"C:\\VMShare\\cmdextension.v1.msi\"\n$msiV2Path = \"C:\\VMShare\\cmdextension.v2.msi\"\n$productName = \"Microsoft Cloud Managed Desktop Extension\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logFilePath = \"C:\\ProgramData\\CloudManagedDesktopExtension\\CMDExtension.log\"\n\n# Check if MSI files exist\nif (-not (Test-Path $msiV1Path)) {\n    Write-Result -Msg \"MSI v1 file not found: $msiV1Path\" -Success $false\n    Stop-Transcript\n    exit 1\n}\nif (-not (Test-Path $msiV2Path)) {\n    Write-Result -Msg \"MSI v2 file not found: $msiV2Path\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Check if product is already installed (by service existence)\n$serviceExists = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif ($serviceExists) {\n    Write-Result -Msg \"Service '$serviceName' already installed. Attempting to uninstall for clean test...\" -Success $false\n    # Try uninstalling both versions\n    $uninstallCmd = \"msiexec.exe /x `\"$msiV1Path`\" /qn\"\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiV1Path`\" /qn\" -Wait -PassThru).ExitCode\n    Start-Sleep -Seconds 10\n    $exitCode2 = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiV2Path`\" /qn\" -Wait -PassThru).ExitCode\n    Start-Sleep -Seconds 10\n    # Check if service is gone\n    $serviceExists = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n    if (-not $serviceExists) {\n        Write-Result -Msg \"Previous installation cleaned up.\" -Success $true\n    } else {\n        Write-Result -Msg \"Failed to clean previous installation. Manual cleanup required.\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 2: INSTALLATION (v1)\n# ============================================================\nWrite-Host \"Installing agent v1...\" -ForegroundColor Cyan\n\ntry {\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiV1Path`\" /qn SVCENV=`\"Test`\"\" -Wait -PassThru).ExitCode\n    Write-Host \"MSI v1 install exit code: $exitCode\" -ForegroundColor Gray\n    if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n        Write-Result -Msg \"MSI v1 installed successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI v1 installation failed (exit code $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI v1 installation: $_\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for agent to initialize\nStart-Sleep -Seconds 60\n\n# ============================================================\n# PHASE 3: VERIFICATION (v1)\n# ============================================================\nWrite-Host \"Verifying agent v1 installation...\" -ForegroundColor Cyan\n\n# 1. Check CMDExtension.log for \"DeviceClient created and opened successfully\"\n$logFound = $false\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath -ErrorAction SilentlyContinue\n    if ($logContent -match \"DeviceClient created and opened successfully\") {\n        $logFound = $true\n    }\n}\nWrite-Result -Msg \"CMDExtension.log contains 'DeviceClient created and opened successfully'\" -Success $logFound\n\n# 2. WMI Table Check\ntry {\n    $sc = Get-WmiObject -Namespace \"root/cmd/clientagent\" -Class SchedulerEntity -ErrorAction Stop\n    $test1 = @()\n    for ($i=0; $i -lt $sc.Length; $i++) {\n        $test1 += $sc[$i].PolicyId\n    }\n    $test2 = $test1 | Select-Object -Unique\n    $wmiCheck = ($test1.Length -eq $test2.Length)\n    Write-Result -Msg \"WMI SchedulerEntity PolicyId uniqueness check (v1)\" -Success $wmiCheck\n} catch {\n    Write-Result -Msg \"WMI query failed (v1): $_\" -Success $false\n}\n\n# ============================================================\n# PHASE 2: UPGRADE INSTALLATION (v2)\n# ============================================================\nWrite-Host \"Upgrading agent to v2...\" -ForegroundColor Cyan\n\ntry {\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i `\"$msiV2Path`\" /qn SVCENV=`\"Test`\"\" -Wait -PassThru).ExitCode\n    Write-Host \"MSI v2 install exit code: $exitCode\" -ForegroundColor Gray\n    if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n        Write-Result -Msg \"MSI v2 installed/upgraded successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI v2 installation/upgrade failed (exit code $exitCode)\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI v2 installation: $_\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for agent to initialize\nStart-Sleep -Seconds 60\n\n# ============================================================\n# PHASE 3: VERIFICATION (v2)\n# ============================================================\nWrite-Host \"Verifying agent v2 installation...\" -ForegroundColor Cyan\n\n# 1. Check CMDExtension.log for \"DeviceClient created and opened successfully\"\n$logFound = $false\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath -ErrorAction SilentlyContinue\n    if ($logContent -match \"DeviceClient created and opened successfully\") {\n        $logFound = $true\n    }\n}\nWrite-Result -Msg \"CMDExtension.log contains 'DeviceClient created and opened successfully' (v2)\" -Success $logFound\n\n# 2. WMI Table Check\ntry {\n    $sc = Get-WmiObject -Namespace \"root/cmd/clientagent\" -Class SchedulerEntity -ErrorAction Stop\n    $test1 = @()\n    for ($i=0; $i -lt $sc.Length; $i++) {\n        $test1 += $sc[$i].PolicyId\n    }\n    $test2 = $test1 | Select-Object -Unique\n    $wmiCheck = ($test1.Length -eq $test2.Length)\n    Write-Result -Msg \"WMI SchedulerEntity PolicyId uniqueness check (v2)\" -Success $wmiCheck\n} catch {\n    Write-Result -Msg \"WMI query failed (v2): $_\" -Success $false\n}\n\n# 3. Verify product is present and version is v2\n# Get installed product version from registry\nfunction Get-MSIProductVersion {\n    param([string]$msiPath)\n    $msiName = Split-Path $msiPath -Leaf\n    $productCode = \"\"\n    # Try to extract ProductCode from MSI\n    try {\n        $windowsInstaller = New-Object -ComObject WindowsInstaller.Installer\n        $database = $windowsInstaller.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $windowsInstaller, @($msiPath, 0))\n        $view = $database.GetType().InvokeMember(\"OpenView\", 'InvokeMethod', $null, $database, @(\"SELECT * FROM Property WHERE Property = 'ProductCode'\"))\n        $view.GetType().InvokeMember(\"Execute\", 'InvokeMethod', $null, $view, $null)\n        $record = $view.GetType().InvokeMember(\"Fetch\", 'InvokeMethod', $null, $view, $null)\n        if ($record) {\n            $productCode = $record.GetType().InvokeMember(\"StringData\", 'GetProperty', $null, $record, 2)\n        }\n    } catch {\n        $productCode = \"\"\n    }\n    if ($productCode) {\n        $regPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productCode\"\n        if (Test-Path $regPath) {\n            $props = Get-ItemProperty $regPath\n            return $props.DisplayVersion\n        }\n    }\n    return $null\n}\n\n$v2Version = Get-MSIProductVersion -msiPath $msiV2Path\n$foundVersion = $null\n# Search in registry for installed product\n$uninstallPaths = @(\n    \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n)\n$found = $false\nforeach ($path in $uninstallPaths) {\n    $keys = Get-ChildItem $path -ErrorAction SilentlyContinue\n    foreach ($key in $keys) {\n        $props = Get-ItemProperty $key.PSPath -ErrorAction SilentlyContinue\n        if ($props.DisplayName -eq $productName) {\n            $found = $true\n            $foundVersion = $props.DisplayVersion\n            break\n        }\n    }\n    if ($found) { break }\n}\nif ($found -and $foundVersion -eq $v2Version) {\n    Write-Result -Msg \"Product '$productName' is present with version $foundVersion (expected v2)\" -Success $true\n} elseif ($found) {\n    Write-Result -Msg \"Product '$productName' is present but version mismatch: $foundVersion (expected $v2Version)\" -Success $false\n} else {\n    Write-Result -Msg \"Product '$productName' not found in installed programs\" -Success $false\n}\n\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"Cleaning up: Uninstalling agent v2...\" -ForegroundColor Cyan\n\ntry {\n    $exitCode = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiV2Path`\" /qn\" -Wait -PassThru).ExitCode\n    Write-Host \"MSI v2 uninstall exit code: $exitCode\" -ForegroundColor Gray\n    if ($exitCode -eq 0 -or $exitCode -eq 3010 -or $exitCode -eq 1605) {\n        Write-Result -Msg \"MSI v2 uninstalled successfully (exit code $exitCode)\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI v2 uninstall failed (exit code $exitCode)\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI v2 uninstall: $_\" -Success $false\n}\n\n# Verify service is removed\n$serviceExists = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif (-not $serviceExists) {\n    Write-Result -Msg \"Service '$serviceName' removed after uninstall\" -Success $true\n} else {\n    Write-Result -Msg \"Service '$serviceName' still present after uninstall\" -Success $false\n}\n\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"\"\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
{"messages": [{"role": "system", "content": "You are an expert Windows PowerShell automation engineer specializing in test script generation.\n\nYour task is to generate production-ready PowerShell test scripts that:\n1. Are goal-oriented (not step-by-step UI simulation)\n2. Use silent installation/uninstallation (MSI with /qn flag)\n3. Verify results through scripts (registry, services, files) NOT UI\n4. Run in a single administrator PowerShell session\n5. Include proper error handling and exit codes\n6. Provide colored output and progress indicators\n7. Generate comprehensive test reports\n\nGiven a test case description with steps and expected results, you generate a complete, executable PowerShell script that performs installation, verification, and cleanup automatically."}, {"role": "user", "content": "Test Case ID: testcase-34714753\n\nGenerate a PowerShell test script for the following test case:\n\n**Step 1**\nAction: Apply to all devices.\n\n**Step 2**\nAction: Press “Win + E” keys, open File Explorer, go to the folder where “cmdextension.msi” locates,cmdextension.msi locates in C:\\VMShare\n\n**Step 3**\nAction: In file explorer, click on “File -> Open Windows PowerShell -> Open Windows PowerShell as administrator”\n\n**Step 4**\nAction: Run command: msiexec /i cmdextension.msi /qn+\nExpected Result: The prompt window should pop up: Title is “Microsoft Cloud Manage Desktop Extension”, and Message is “Microsoft Cloud Managed Desktop Extension Setup completed successfully.”\n\nIf the step failed, run: msiexec /i cmdextension.msi /qn+ /l*v mylog. Send mylog to CMD Agent team for troubleshooting\n\n**Step 5**\nAction: Open “Control Panel -> Programs -> Uninstall a program”\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” is present in the list of installed programs.\n\n**Step 6**\nAction: Open “Task Manager -> Services”\nExpected Result: Verify “CloudManagedDesktopExtension”\nis in running state.\n\n**Step 7**\nAction: Press “Win + R” keys, type “services.msc” and press Enter.\nExpected Result: Verify “Microsoft Cloud Managed Desktop Extension” - Status is “Running”, Startup Type is “Automatic (Delayed Start)”, and Log On As is “Local System”.\n\n**Step 8**\nAction: Open file explorer, go to %ProgramData%\\Microsoft\\CMDExtension\\Logs.\nExpected Result: Verify “CMDExtension.log” is present.\n\n**Step 9**\nAction: Press “Win + R” keys, type “taskschd.msc” and press Enter. Open “Task scheduler library -> Microsoft -> CMD”\nExpected Result: Verify “Cloud Managed Desktop Extension Health Evaluation” is present.\n\n**Step 10**\nAction: Press “Win + R” keys, type “wbemtest” and press Enter. Click on “Connect”, type “root\\cmd\\clientagent” and press Enter.\nExpected Result: Verify there is NOT error prompt window which displays “Invalid namespace”.\n\n**Step 11**\nAction: Test Cleanup:\n\n\nIn the same PowerShell window as “Step 3”, run command: msiexec /x cmdextension.msi\n\nRequirements:\n- Use silent installation (MSI with /qn flag, not /qn+)\n- Verify through scripts (registry, services, files) NOT UI\n- Include proper error handling and logging\n- Provide colored console output\n- Generate a summary report at the end\n"}, {"role": "assistant", "content": "﻿# ============================================================\n# SETUP LOGGING\n# ============================================================\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$logDir = \"$PSScriptRoot\\..\\output\\logs\"\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n$test_case_id = \"case13test\"\n$logFile = Join-Path $logDir \"test_${test_case_id}_$timestamp.log\"\n\n# Start transcript to capture all output\nStart-Transcript -Path $logFile -Append\n\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION START: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" -ForegroundColor Cyan\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# ============================================================\n# PHASE 1: PRE-CHECK\n# ============================================================\nWrite-Host \"Checking prerequisites...\" -ForegroundColor Cyan\n\n$script:SuccessCount = 0\n$script:FailCount = 0\n\nfunction Write-Result {\n    param([string]$Msg, [bool]$Success)\n    if ($Success -eq $true) {\n        Write-Host \"[PASS] $Msg\" -ForegroundColor Green\n        $script:SuccessCount++\n    } else {\n        Write-Host \"[FAIL] $Msg\" -ForegroundColor Red\n        $script:FailCount++\n    }\n}\n\n# Check admin privileges\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Host \"[FAIL] ERROR: Must run as Administrator\" -ForegroundColor Red\n    Stop-Transcript\n    exit 1\n}\n\n# Define MSI path and product/service names\n$msiPath = \"C:\\VMShare\\cmdextension.msi\"\n$serviceName = \"CloudManagedDesktopExtension\"\n$logDirPath = \"$env:ProgramData\\Microsoft\\CMDExtension\\Logs\"\n$logFilePath = Join-Path $logDirPath \"CMDExtension.log\"\n$regPath_x64 = \"HKLM:\\SOFTWARE\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n$regPath_x86 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\CloudManagementDesktop\\Extension\\Settings\"\n\n# Check if product is already installed\nfunction Get-MSIProductCode {\n    param([string]$msiPath)\n    $msi = New-Object -ComObject WindowsInstaller.Installer\n    $db = $msi.GetType().InvokeMember(\"OpenDatabase\", 'InvokeMethod', $null, $msi, @($msiPath, 0))\n    $view = $db.OpenView(\"SELECT * FROM Property WHERE Property = 'ProductCode'\")\n    $view.Execute()\n    $record = $view.Fetch()\n    if ($record) {\n        return $record.StringData(2)\n    }\n    return $null\n}\n$productCode = Get-MSIProductCode -msiPath $msiPath\n\n$alreadyInstalled = $false\nif ($productCode) {\n    $installed = Get-WmiObject -Class Win32_Product | Where-Object { $_.IdentifyingNumber -eq $productCode }\n    if ($installed) {\n        $alreadyInstalled = $true\n    }\n}\n\nif ($alreadyInstalled) {\n    Write-Result -Msg \"Product already installed. Uninstalling before test...\" -Success $false\n    $uninstallCmd = \"msiexec.exe /x `\"$msiPath`\" /qn\"\n    $uninstallProc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru\n    $uninstallExitCode = $uninstallProc.ExitCode\n    if ($uninstallExitCode -eq 0 -or $uninstallExitCode -eq 1605) {\n        Write-Result -Msg \"Previous installation removed successfully.\" -Success $true\n    } else {\n        Write-Result -Msg \"Failed to uninstall previous installation. Exit code: $uninstallExitCode\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 2: INSTALLATION\n# ============================================================\nWrite-Host \"Installing client agent...\" -ForegroundColor Cyan\n$installArgs = \"/i `\"$msiPath`\" SVCENV=`\"Test`\" /qn\"\ntry {\n    $proc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList $installArgs -Wait -PassThru\n    $exitCode = $proc.ExitCode\n    if ($exitCode -eq 0 -or $exitCode -eq 3010) {\n        Write-Result -Msg \"MSI installed successfully. Exit code: $exitCode\" -Success $true\n    } elseif ($exitCode -eq 1603) {\n        Write-Result -Msg \"Installation failed (1603).\" -Success $false\n        Stop-Transcript\n        exit 1\n    } elseif ($exitCode -eq 1618) {\n        Write-Result -Msg \"Another installation in progress (1618).\" -Success $false\n        Stop-Transcript\n        exit 1\n    } elseif ($exitCode -eq 1925) {\n        Write-Result -Msg \"Insufficient privileges (1925).\" -Success $false\n        Stop-Transcript\n        exit 1\n    } else {\n        Write-Result -Msg \"MSI installation failed. Exit code: $exitCode\" -Success $false\n        Stop-Transcript\n        exit 1\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI installation: $_\" -Success $false\n    Stop-Transcript\n    exit 1\n}\n\n# Wait for service to start\nStart-Sleep -Seconds 10\n$service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif ($service -and $service.Status -eq 'Running') {\n    Write-Result -Msg \"Service '$serviceName' is running after install.\" -Success $true\n} else {\n    Write-Result -Msg \"Service '$serviceName' is NOT running after install.\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 3: VERIFICATION\n# ============================================================\nWrite-Host \"Starting test scenario actions and verification...\" -ForegroundColor Cyan\n\n# Step 5: Check log file for \"Hit iot connection info cache\" and \"DeviceClient created and opened successfully\"\n$step5_found_cache = $false\n$step5_found_deviceclient = $false\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath -Raw\n    if ($logContent -match \"Hit iot connection info cache\") {\n        $step5_found_cache = $true\n    }\n    if ($logContent -match \"DeviceClient created and opened successfully\") {\n        $step5_found_deviceclient = $true\n    }\n    Write-Result -Msg \"Log contains 'Hit iot connection info cache'.\" -Success $step5_found_cache\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully'.\" -Success $step5_found_deviceclient\n} else {\n    Write-Result -Msg \"Log file not found at $logFilePath\" -Success $false\n}\n\n# Step 6: Stop service\ntry {\n    Stop-Service -Name $serviceName -Force -ErrorAction Stop\n    Start-Sleep -Seconds 5\n    $service = Get-Service -Name $serviceName\n    Write-Result -Msg \"Service '$serviceName' stopped successfully.\" -Success ($service.Status -eq 'Stopped')\n} catch {\n    Write-Result -Msg \"Failed to stop service '$serviceName': $_\" -Success $false\n}\n\n# Step 7/8: Update registry IoTHostName to \"foo-device.net\"\n$regPath = if (Test-Path $regPath_x64) { $regPath_x64 } elseif (Test-Path $regPath_x86) { $regPath_x86 } else { $null }\nif ($regPath) {\n    try {\n        Set-ItemProperty -Path $regPath -Name \"IoTHostName\" -Value \"foo-device.net\"\n        $newVal = (Get-ItemProperty -Path $regPath -Name \"IoTHostName\").IoTHostName\n        Write-Result -Msg \"Registry 'IoTHostName' updated to 'foo-device.net'.\" -Success ($newVal -eq \"foo-device.net\")\n    } catch {\n        Write-Result -Msg \"Failed to update registry 'IoTHostName': $_\" -Success $false\n    }\n} else {\n    Write-Result -Msg \"Registry path for settings not found.\" -Success $false\n}\n\n# Step 9: Start service and wait for 25 minutes (simulate with shorter wait for automation)\ntry {\n    Start-Service -Name $serviceName -ErrorAction Stop\n    # For automation, reduce wait to 60 seconds instead of 25 minutes\n    Start-Sleep -Seconds 60\n    $service = Get-Service -Name $serviceName\n    Write-Result -Msg \"Service '$serviceName' started successfully.\" -Success ($service.Status -eq 'Running')\n} catch {\n    Write-Result -Msg \"Failed to start service '$serviceName': $_\" -Success $false\n}\n\n# Step 10: Check log for multiple \"IoTHostName: foo-device.net\" and \"DeviceClient created and opened successfully\"\n$step10_found_iothost = $false\n$step10_found_deviceclient = $false\n$step10_iothost_count = 0\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath\n    $step10_iothost_count = ($logContent | Select-String \"IoTHostName: foo-device.net\").Count\n    $step10_found_deviceclient = ($logContent | Select-String \"DeviceClient created and opened successfully\").Count -gt 0\n    $step10_found_iothost = ($step10_iothost_count -gt 1)\n    Write-Result -Msg \"Log contains more than one 'IoTHostName: foo-device.net'.\" -Success $step10_found_iothost\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully' after IoTHostName update.\" -Success $step10_found_deviceclient\n} else {\n    Write-Result -Msg \"Log file not found for step 10.\" -Success $false\n}\n\n# Step 11: Update registry IoTDeviceId to \"fooDeviceId\" and restart service\nif ($regPath) {\n    try {\n        Set-ItemProperty -Path $regPath -Name \"IoTDeviceId\" -Value \"fooDeviceId\"\n        $newVal = (Get-ItemProperty -Path $regPath -Name \"IoTDeviceId\").IoTDeviceId\n        Write-Result -Msg \"Registry 'IoTDeviceId' updated to 'fooDeviceId'.\" -Success ($newVal -eq \"fooDeviceId\")\n    } catch {\n        Write-Result -Msg \"Failed to update registry 'IoTDeviceId': $_\" -Success $false\n    }\n} else {\n    Write-Result -Msg \"Registry path for settings not found (IoTDeviceId).\" -Success $false\n}\ntry {\n    Restart-Service -Name $serviceName -ErrorAction Stop\n    # For automation, reduce wait to 30 seconds instead of 10 minutes\n    Start-Sleep -Seconds 30\n    $service = Get-Service -Name $serviceName\n    Write-Result -Msg \"Service '$serviceName' restarted successfully.\" -Success ($service.Status -eq 'Running')\n} catch {\n    Write-Result -Msg \"Failed to restart service '$serviceName': $_\" -Success $false\n}\n\n# Step 12: Check log for error codes and successful retry\n$step12_found_error = $false\n$step12_found_update = $false\n$step12_found_deviceclient = $false\nif (Test-Path $logFilePath) {\n    $logContent = Get-Content $logFilePath -Raw\n    $errorPatterns = @('\"errorCode\":401002', 'DeviceNotFoundException', 'status-code: 404', 'Exception on RegisterAsync')\n    foreach ($pattern in $errorPatterns) {\n        if ($logContent -match $pattern) {\n            $step12_found_error = $true\n            break\n        }\n    }\n    $step12_found_update = ($logContent -match \"Update IoTDeviceId to\")\n    $step12_found_deviceclient = ($logContent -match \"DeviceClient created and opened successfully\")\n    Write-Result -Msg \"Log contains expected error codes or exceptions.\" -Success $step12_found_error\n    Write-Result -Msg \"Log contains 'Update IoTDeviceId to' after error.\" -Success $step12_found_update\n    Write-Result -Msg \"Log contains 'DeviceClient created and opened successfully' after error.\" -Success $step12_found_deviceclient\n} else {\n    Write-Result -Msg \"Log file not found for step 12.\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# PHASE 4: CLEANUP\n# ============================================================\nWrite-Host \"Cleaning up: Uninstalling client agent...\" -ForegroundColor Cyan\ntry {\n    $uninstallProc = Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait -PassThru\n    $uninstallExitCode = $uninstallProc.ExitCode\n    if ($uninstallExitCode -eq 0 -or $uninstallExitCode -eq 1605) {\n        Write-Result -Msg \"MSI uninstalled successfully. Exit code: $uninstallExitCode\" -Success $true\n    } else {\n        Write-Result -Msg \"MSI uninstall failed. Exit code: $uninstallExitCode\" -Success $false\n    }\n} catch {\n    Write-Result -Msg \"Exception during MSI uninstall: $_\" -Success $false\n}\n\n# Verify service removed\n$service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif (-not $service) {\n    Write-Result -Msg \"Service '$serviceName' removed after uninstall.\" -Success $true\n} else {\n    Write-Result -Msg \"Service '$serviceName' still present after uninstall.\" -Success $false\n}\n\nWrite-Host \"\"\n# ============================================================\n# SUMMARY\n# ============================================================\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"TEST EXECUTION SUMMARY\" -ForegroundColor Cyan\nWrite-Host \"============================================================\" -ForegroundColor Cyan\nWrite-Host \"Total Passed: $script:SuccessCount\" -ForegroundColor Green\nWrite-Host \"Total Failed: $script:FailCount\" -ForegroundColor Red\nWrite-Host \"Log file: $logFile\" -ForegroundColor Gray\nWrite-Host \"============================================================\" -ForegroundColor Cyan\n\nStop-Transcript\n\nWrite-Host \"\"\nWrite-Host \"Press any key to exit...\" -ForegroundColor Yellow\n$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')"}]}
